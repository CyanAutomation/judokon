[{"filePath":"/home/runner/work/judokon/judokon/.bin/scan_helpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.cache/scan_pseudocode.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.cache/scan_pseudocode.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.github/workflows/eslint.yml","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.github/workflows/jsdocCheck.yml","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.github/workflows/lintAutofix.yml","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.github/workflows/playwrightBaseline.yml","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.github/workflows/runUnitTests.yml","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.github/workflows/syncAgentDocs.yml","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.github/workflows/updateCardCodes.yml","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/.github/workflows/updateEmbeddings.yml","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/pa11y.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/battle-cli.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/battle-next-readiness.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/battle-next-skip.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/battle-state-progress.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/battleRoundCompletion.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/browse-judoka.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/card-inspector-accessibility.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/classicBattleFlow.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/cli-flows.spec.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/cli-scroll.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/cli.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/cli.spec.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/countdown.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/fixtures/classicBattleStates.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/fixtures/commonRoutes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/fixtures/commonSetup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/fixtures/navigationChecks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/fixtures/waits.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/homepage-layout.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/homepage.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/hover-zoom.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/local.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/meditation-screen.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/narrow-layout.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/navigation.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/prd-reader.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/pseudo-japanese-toggle.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/random-judoka.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/screenshot.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/settings-collapse.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/settings.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/static-pages.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/status-aria-attributes.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/tooltip.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/vector-search.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/playwright/waits-timeout.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/buildOfflineRag.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/check-jsdoc.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/checkBattleCliLayout.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/collectTestStats.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/debugBattleProgression.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/debugHeaderLayout.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/debugSnackbar.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/diagnosePlaywright.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/diagnosePlaywright.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/diagnosePlaywrightInteractive.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/diagnosePlaywrightNode.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/evaluateBattleCLI.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/evaluation/evaluateRAG.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/generateCodeGraphs.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/generateEmbeddings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/generatePrdIndex.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/lib/debugUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/networkProbe.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/playwrightServer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/print-jsdoc-priority.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/queryRagCli.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/run-check-jsdoc.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/runPa11y.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/runRoundToCompletion.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/syncAgentDocs.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/validateData.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/scripts/waitForRoundResolve.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/Button.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/Card.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/EpicCard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/JudokaCard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/Modal.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/PlayerInfo.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/PreviewToggle.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/Scoreboard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/SidebarList.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/Spinner.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/StatsPanel.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/components/ToggleSwitch.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/config/battleDefaults.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/config/loadSettings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/config/settingsDefaults.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/config/storageKeys.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/data/battleRounds.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/data/gameTimers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/data/japaneseConverter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/data/navigationItems.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/data/statNames.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/game.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/gameBootstrap.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/BattleEngine.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/CooldownRenderer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/TimerController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/api/battleUI.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/api/countryService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/api/vectorSearchPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/battle/battleUI.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/battle/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/battle/score.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/battleEngineFacade.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/battleInit.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/battleJudokaPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/battleStateProgress.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/browse/handleKeyboardNavigation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/browse/setupCountryFilter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/browse/setupCountryToggle.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/browseJudokaPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/buttonEffects.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/cardBuilder.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/cardCode.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/cardFlip.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/cardRender.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/cardSections.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/cardTopBar.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/cardUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/accessibility.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/cards.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/controller.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/focus.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/metrics.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/navigation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/responsive.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/scroll.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carousel/structure.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carouselBuilder.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/carouselScroll.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/changeLogPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/autoSelectStat.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/battleDebug.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/battleEvents.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/bootstrap.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/cardSelection.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/cardStatUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/controller.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/debugHooks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/eventBus.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/guard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/interruptHandlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/opponentController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/orchestrator.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/orchestratorHandlers.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getNextRoundControls' is defined but never used.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"getNextRoundControls"},"fix":{"range":[61,82],"text":""},"desc":"Remove unused variable 'getNextRoundControls'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getDefaultTimer } from \"../timerUtils.js\";\nimport { getNextRoundControls, setupFallbackTimer } from \"./roundManager.js\";\nimport { isTestModeEnabled } from \"../testModeUtils.js\";\nimport { getOpponentJudoka } from \"./cardSelection.js\";\nimport { getStatValue } from \"../battle/index.js\";\nimport { emitBattleEvent, onBattleEvent, offBattleEvent } from \"./battleEvents.js\";\nimport { resolveRound } from \"./roundResolver.js\";\nimport { guard, guardAsync, scheduleGuard } from \"./guard.js\";\nimport { exposeDebugState, readDebugState } from \"./debugHooks.js\";\nimport { debugLog } from \"../debug.js\";\n// Removed unused import for enableNextRoundButton\n\n/**\n * Whether the orchestrator should automatically dispatch \"continue\" after an\n * outcome. Consumers like the CLI can toggle this for readability.\n * @type {boolean}\n */\nexport let autoContinue = true;\n\n/**\n * Update the `autoContinue` behavior.\n * @param {boolean} val\n */\nexport function setAutoContinue(val) {\n  autoContinue = val !== false;\n}\n\n/**\n * Handle round-related errors in a consistent manner.\n *\n * @param {object} machine\n * @param {string} reason\n * @param {Error} err\n * @returns {Promise<void>}\n * @pseudocode\n * 1. Show a generic round error message on the scoreboard.\n * 2. Update the debug panel for visibility.\n * 3. Dispatch an interrupt with the reason and `err.message`.\n */\nexport async function handleRoundError(machine, reason, err) {\n  guard(() => emitBattleEvent(\"scoreboardShowMessage\", \"Round error. Recovering…\"));\n  guard(() => emitBattleEvent(\"debugPanelUpdate\"));\n  await guardAsync(() => machine.dispatch(\"interrupt\", { reason, error: err?.message }));\n}\n\n/**\n * Determine whether the machine transitioned from `from` to `to`.\n *\n * @pseudocode\n * 1. Read current and previous state from `document.body.dataset`.\n * 2. If `from` is null/undefined, compare only current → `to`.\n * 3. Otherwise, return whether previous equals `from` and current equals `to`.\n * 4. Return false on any error.\n *\n * @param {string|null|undefined} from\n * @param {string} to\n * @returns {boolean}\n */\nexport function isStateTransition(from, to) {\n  try {\n    if (typeof document === \"undefined\") return false;\n    const current = document.body?.dataset.battleState;\n    const prev = document.body?.dataset.prevBattleState;\n    if (from === null || from === undefined) {\n      return current === to;\n    }\n    return prev === from && current === to;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Initialize the match start cooldown timer.\n *\n * @pseudocode\n * 1. Resolve match start duration with 3s default.\n * 2. Emit `countdownStart` and listen for `countdownFinished`.\n * 3. Schedule fallback timer to dispatch `ready` if no event fires.\n */\nexport async function initStartCooldown(machine) {\n  let duration = 3;\n  try {\n    const val = await getDefaultTimer(\"matchStartTimer\");\n    if (typeof val === \"number\") duration = val;\n  } catch {}\n  duration = Math.max(1, Number(duration));\n  let fallback = null;\n  const onFinished = () => {\n    try {\n      offBattleEvent(\"countdownFinished\", onFinished);\n    } catch {}\n    try {\n      if (fallback) clearTimeout(fallback);\n    } catch {}\n    try {\n      machine.dispatch(\"ready\");\n    } catch {}\n  };\n  onBattleEvent(\"countdownFinished\", onFinished);\n  emitBattleEvent(\"countdownStart\", { duration });\n  // In test mode, auto-advance without relying on timers which are often faked.\n  try {\n    if (isTestModeEnabled && isTestModeEnabled()) {\n      if (typeof queueMicrotask === \"function\") queueMicrotask(onFinished);\n      else setTimeout(onFinished, 0);\n      return;\n    }\n  } catch {}\n  try {\n    // Prefer the roundManager helper when available; fall back to setTimeout.\n    const schedule = typeof setupFallbackTimer === \"function\" ? setupFallbackTimer : setTimeout;\n    fallback = schedule(duration * 1000 + 200, onFinished);\n  } catch {\n    // Last resort: attempt a direct transition\n    onFinished();\n  }\n}\n\n/**\n * Initialize the inter-round cooldown timer.\n *\n * This function is now the sole owner of the inter-round cooldown logic when\n * the orchestrator is active. It starts a countdown, and when it finishes,\n * it marks the \"Next\" button as ready.\n *\n * @param {object} machine The state machine instance.\n * @pseudocode\n * 1. Get the cooldown duration from `computeNextRoundCooldown`.\n * 2. Define an `onFinished` callback that:\n *    - Marks the `#next-button` with `data-next-ready=\"true\"`.\n *    - Emits the `nextRoundTimerReady` event.\n *    - Dispatches \"ready\" to the state machine.\n * 3. Emit the `countdownStart` event with the calculated duration and the `onFinished` callback.\n */\nexport async function initInterRoundCooldown(machine) {\n  const { computeNextRoundCooldown } = await import(\"../timers/computeNextRoundCooldown.js\");\n  const duration = computeNextRoundCooldown();\n\n  const onFinished = () => {\n    try {\n      const nextButton = document.getElementById(\"next-button\");\n      if (nextButton) {\n        nextButton.dataset.nextReady = \"true\";\n      }\n      emitBattleEvent(\"nextRoundTimerReady\");\n      machine.dispatch(\"ready\");\n    } catch (err) {\n      console.error(\"Error in initInterRoundCooldown.onFinished:\", err);\n    }\n  };\n\n  emitBattleEvent(\"countdownStart\", { duration, onFinished });\n}\n\n/**\n * onEnter handler for `waitingForMatchStart` state.\n *\n * @pseudocode\n * 1. If this is a no-op transition, return early.\n * 2. Call `doResetGame` from machine context when available.\n * 3. Emit events to clear the scoreboard and refresh debug panel.\n *\n * @param {object} machine\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * onEnter handler for `waitingForMatchStart`.\n *\n * @pseudocode\n * 1. No-op if the machine re-entered the same state.\n * 2. Call `doResetGame` from machine.context when available.\n * 3. Emit UI events to clear messages and update debug panels.\n * 4. Import and call scoreboard/UI helpers to ensure they are initialized.\n *\n * @param {object} machine\n */\nexport async function waitingForMatchStartEnter(machine) {\n  if (isStateTransition(\"waitingForMatchStart\", \"waitingForMatchStart\")) return;\n  const { doResetGame } = machine.context;\n  if (typeof doResetGame === \"function\") doResetGame();\n  emitBattleEvent(\"scoreboardClearMessage\");\n  emitBattleEvent(\"debugPanelUpdate\");\n  // Also directly invoke UI side-effects to guarantee initialization in tests/runtime\n  try {\n    const scoreboard = await import(\"../setupScoreboard.js\");\n    scoreboard.clearMessage?.();\n  } catch {}\n  try {\n    const helpers = await import(\"./uiHelpers.js\");\n    helpers.updateDebugPanel?.();\n  } catch {}\n}\n\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * onEnter handler for `matchStart` state.\n *\n * @pseudocode\n * 1. Dispatch `ready` immediately to proceed with initial match flow.\n *\n * @param {object} machine\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\nexport async function matchStartEnter(machine) {\n  await machine.dispatch(\"ready\", { initial: true });\n}\n\n/**\n * onEnter handler for `cooldown` state.\n *\n * @pseudocode\n * 1. If `payload.initial`, delegate to `initStartCooldown`.\n * 2. Otherwise, ensure an inter-round cooldown is scheduled via roundManager when none exists.\n *\n * @param {object} machine\n * @param {object} [payload]\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. If initial cooldown requested → `initStartCooldown`.\n * 2. Else → schedule `roundManager.startCooldown` if not already scheduled.\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * onEnter handler for `cooldown` state.\n *\n * @pseudocode\n * 1. If `payload.initial` -> initialize start cooldown.\n * 2. Otherwise ensure inter-round cooldown is scheduled when absent.\n *\n * @param {object} machine\n * @param {object} [payload]\n */\nexport async function cooldownEnter(machine, payload) {\n  if (payload?.initial) {\n    return initStartCooldown(machine);\n  }\n  // The orchestrator now owns the inter-round cooldown.\n  return initInterRoundCooldown(machine);\n}\n\n/**\n * onEnter handler for `roundStart` state.\n *\n * @pseudocode\n * 1. Start the round via `startRoundWrapper` or `doStartRound` asynchronously.\n * 2. Install a short fallback in test/headless mode to advance to `cardsRevealed` to avoid stalls.\n * 3. If rendering fails, emit an error message and dispatch `interrupt`.\n * 4. If still in `roundStart`, dispatch `cardsRevealed` to proceed.\n *\n * @param {object} machine\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * Install a short timer that advances past `roundStart` in test environments.\n *\n * @param {object} machine\n * @returns {ReturnType<typeof setTimeout>|null}\n */\nfunction installRoundStartFallback(machine) {\n  if (!isTestModeEnabled || !isTestModeEnabled()) return null;\n  return setupFallbackTimer(50, () => {\n    guardAsync(async () => {\n      const state = machine.getState ? machine.getState() : null;\n      if (state === \"roundStart\") await machine.dispatch(\"cardsRevealed\");\n    });\n  });\n}\n\n/**\n * Invoke the round start routine from the provided context.\n *\n * @param {{startRoundWrapper?: Function, doStartRound?: Function, store?: any}} ctx\n * @returns {any}\n */\nfunction invokeRoundStart(ctx) {\n  const { startRoundWrapper, doStartRound, store } = ctx;\n  if (typeof startRoundWrapper === \"function\") return startRoundWrapper();\n  if (typeof doStartRound === \"function\") return doStartRound(store);\n  return Promise.resolve();\n}\n\n/**\n * onEnter handler for `roundStart` state.\n *\n * @pseudocode\n * 1. Install a short fallback in test mode to advance if UI stalls.\n * 2. Invoke the round start routine from the machine context.\n * 3. On failure → clear fallback and handleRoundError(`roundStartError`).\n * 4. If start succeeds and state still `roundStart` → dispatch `cardsRevealed`.\n *\n * @param {object} machine\n */\nexport async function roundStartEnter(machine) {\n  const fallback = installRoundStartFallback(machine);\n  try {\n    await Promise.resolve(invokeRoundStart(machine.context));\n    guard(() => {\n      if (fallback) clearTimeout(fallback);\n    });\n    await guardAsync(async () => {\n      const state = machine.getState ? machine.getState() : null;\n      if (state === \"roundStart\") await machine.dispatch(\"cardsRevealed\");\n    });\n  } catch (err) {\n    guard(() => {\n      if (fallback) clearTimeout(fallback);\n    });\n    await handleRoundError(machine, \"roundStartError\", err);\n  }\n}\n\n/**\n * onEnter handler for `waitingForPlayerAction` state.\n *\n * @pseudocode\n * 1. Enable stat buttons via battle events.\n * 2. If a selection already exists on the store, dispatch `statSelected` immediately.\n *\n * @param {object} machine\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\nexport async function waitingForPlayerActionEnter(machine) {\n  emitBattleEvent(\"statButtons:enable\");\n  // Do NOT mark the Next button as ready here. The Next button is reserved\n  // for advancing after cooldown between rounds. Enabling it during stat\n  // selection can cause the cooldown scheduler to short-circuit, skipping the\n  // timer and preventing the state machine from progressing — seen as a \"hang\"\n  // on the classic battle page. The CLI page never enables Next during\n  // selection and does not suffer this issue. Keep Next controlled by the\n  // cooldown scheduler only.\n  const store = machine?.context?.store;\n  if (store?.playerChoice) {\n    await machine.dispatch(\"statSelected\");\n  }\n}\n/**\n * onExit handler for `waitingForPlayerAction` state.\n *\n * @pseudocode\n * 1. Emit an event to disable stat buttons.\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\nexport async function waitingForPlayerActionExit() {\n  emitBattleEvent(\"statButtons:disable\");\n}\n\n/**\n * Record that the machine entered `roundDecision` for debug tracing.\n *\n * @pseudocode\n * 1. Log debug entry if not in Vitest.\n * 2. Record `roundDecisionEnter` timestamp via `exposeDebugState`.\n * 3. Emit `debugPanelUpdate` event.\n */\n/**\n * Compute round outcome and dispatch the resulting events.\n *\n * @param {object} store\n * @param {object} machine\n * @returns {Promise<void>}\n * @pseudocode\n * ```\n * if not in roundDecision or already resolved → return\n * if no player choice → dispatch interrupt(stalledNoSelection)\n * outcomeEvent ← determineOutcomeEvent(store)\n * record debug guard timing\n * await dispatchOutcome(outcomeEvent, machine)\n * emit debug panel update\n * ```\n */\nexport async function computeAndDispatchOutcome(store, machine) {\n  try {\n    debugLog(\"DEBUG: computeAndDispatchOutcome start\", { playerChoice: store?.playerChoice });\n    if (!isStateTransition(null, \"roundDecision\")) return;\n    const rd = readDebugState(\"roundDebug\");\n    const resolved = rd && typeof rd.resolvedAt === \"number\";\n    if (resolved) return;\n    if (!store?.playerChoice) {\n      await machine.dispatch(\"interrupt\", { reason: \"stalledNoSelection\" });\n      return;\n    }\n    const outcomeEvent = determineOutcomeEvent(store);\n    debugLog(\"DEBUG: computeAndDispatchOutcome outcomeEvent\", { outcomeEvent });\n    try {\n      exposeDebugState(\"guardFiredAt\", Date.now());\n      exposeDebugState(\"guardOutcomeEvent\", outcomeEvent || \"none\");\n    } catch {}\n    await dispatchOutcome(outcomeEvent, machine);\n    emitBattleEvent(\"debugPanelUpdate\");\n  } catch {}\n}\n\n/**\n * Determine the outcome event based on player and opponent stat values.\n *\n * @param {object} store\n * @returns {string|null}\n * @pseudocode\n * ```\n * read player and opponent values\n * if both numbers → return corresponding outcome event\n * else → null\n * ```\n */\nfunction determineOutcomeEvent(store) {\n  try {\n    const stat = store.playerChoice;\n    const pCard = document.getElementById(\"player-card\");\n    const oCard = document.getElementById(\"opponent-card\");\n    const playerVal = getStatValue(pCard, stat);\n    debugLog(\"DEBUG: computeAndDispatchOutcome values\", { stat, playerVal });\n    let opponentVal = 0;\n    try {\n      const opp = getOpponentJudoka();\n      const raw = opp && opp.stats ? Number(opp.stats[stat]) : NaN;\n      opponentVal = Number.isFinite(raw) ? raw : getStatValue(oCard, stat);\n    } catch {\n      opponentVal = getStatValue(oCard, stat);\n    }\n    if (Number.isFinite(playerVal) && Number.isFinite(opponentVal)) {\n      if (playerVal > opponentVal) return \"outcome=winPlayer\";\n      if (playerVal < opponentVal) return \"outcome=winOpponent\";\n      return \"outcome=draw\";\n    }\n  } catch {}\n  return null;\n}\n\n/**\n * Dispatch the outcome or interrupt if none exists.\n *\n * @param {string|null} outcomeEvent\n * @param {object} machine\n * @returns {Promise<void>}\n * @pseudocode\n * ```\n * if outcome event → schedule dispatch(outcomeEvent) and dispatch(continue)\n * else → dispatch interrupt(guardNoOutcome)\n * ```\n */\nasync function dispatchOutcome(outcomeEvent, machine) {\n  if (outcomeEvent) {\n    // Avoid re-entrant dispatch inside onEnter; schedule transitions\n    // after onEnter/microtasks complete.\n    try {\n      const run = async () => {\n        try {\n          await machine.dispatch(outcomeEvent);\n          if (autoContinue) await machine.dispatch(\"continue\");\n        } catch {}\n      };\n      if (typeof queueMicrotask === \"function\") queueMicrotask(run);\n      setTimeout(run, 0);\n    } catch {\n      try {\n        await machine.dispatch(outcomeEvent);\n        if (autoContinue) await machine.dispatch(\"continue\");\n      } catch {}\n    }\n  } else {\n    await machine.dispatch(\"interrupt\", { reason: \"guardNoOutcome\" });\n  }\n}\n\n/**\n * Schedule a timeout that computes the round outcome if resolution stalls.\n *\n * @param {object} store\n/**\n * Record entry into the round decision state for debug purposes.\n *\n * @pseudocode\n * ```\n * log debug entry if not in Vitest\n * record timestamp on window\n * emit debug panel update\n * ```\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary Stamp round decision entry for diagnostics.\n * @pseudocode\n * 1. Log debug message when not under Vitest.\n * 2. Store `Date.now()` using `exposeDebugState('roundDecisionEnter')`.\n * 3. Emit `debugPanelUpdate` to refresh the panel.\n */\nexport function recordEntry() {\n  try {\n    debugLog(\"DEBUG: Entering roundDecisionEnter\");\n  } catch {}\n  try {\n    if (typeof window !== \"undefined\") {\n      exposeDebugState(\"roundDecisionEnter\", Date.now());\n    }\n  } catch {}\n  emitBattleEvent(\"debugPanelUpdate\");\n}\n\n/**\n * Resolve the round immediately if a selection exists.\n *\n * @param {object} store\n * @returns {Promise<boolean>} whether a resolution occurred\n * @pseudocode\n * ```\n * if no player choice → return false\n * read stat values\n * log debug values\n * await resolveRound\n * return true\n * ```\n */\nexport async function resolveSelectionIfPresent(store) {\n  if (!store.playerChoice) return false;\n  const stat = store.playerChoice;\n  const pCard = document.getElementById(\"player-card\");\n  const oCard = document.getElementById(\"opponent-card\");\n  const playerVal = getStatValue(pCard, stat);\n  let opponentVal = 0;\n  try {\n    const opp = getOpponentJudoka();\n    const raw = opp && opp.stats ? Number(opp.stats[stat]) : NaN;\n    opponentVal = Number.isFinite(raw) ? raw : getStatValue(oCard, stat);\n  } catch {\n    opponentVal = getStatValue(oCard, stat);\n  }\n  try {\n    debugLog(\"DEBUG: roundDecision.resolveImmediate\", { stat, playerVal, opponentVal });\n  } catch {}\n  await resolveRound(store, stat, playerVal, opponentVal);\n  return true;\n}\n\n/**\n * Await a player's stat selection or time out.\n *\n * @param {object} store - Battle store.\n * @param {number} timeoutMs - Maximum wait in milliseconds.\n * @returns {Promise<void>} Resolves on selection or rejects on timeout.\n * @pseudocode\n * 1. If `store.playerChoice` exists → resolve immediately.\n * 2. Listen for `statSelected` battle events.\n * 3. Poll the store for a new `playerChoice`.\n * 4. Start a timeout that rejects after `timeoutMs`.\n * 5. Resolve when either the event fires or the store updates; otherwise reject on timeout.\n */\nexport function waitForPlayerChoice(store, timeoutMs) {\n  if (store.playerChoice) return Promise.resolve();\n\n  let handler;\n  let pollId;\n  let timeoutId;\n\n  const cleanup = () => {\n    offBattleEvent(\"statSelected\", handler);\n    if (pollId) clearInterval(pollId);\n    if (timeoutId) clearTimeout(timeoutId);\n  };\n\n  const eventPromise = new Promise((resolve) => {\n    handler = () => {\n      cleanup();\n      resolve();\n    };\n    onBattleEvent(\"statSelected\", handler);\n  });\n\n  const storePromise = new Promise((resolve) => {\n    pollId = setInterval(() => {\n      if (store.playerChoice) {\n        cleanup();\n        resolve();\n      }\n    }, 50);\n  });\n\n  const timeoutPromise = new Promise((_, reject) => {\n    timeoutId = setTimeout(() => {\n      cleanup();\n      reject(new Error(\"timeout\"));\n    }, timeoutMs);\n  });\n\n  return Promise.race([eventPromise, storePromise, timeoutPromise]);\n}\n\n/**\n * Await a player's choice and resolve the round.\n *\n * @param {object} store\n * @returns {Promise<void>}\n * @pseudocode\n * 1. Wait up to 1500 ms for `waitForPlayerChoice`.\n * 2. Resolve selection via `resolveSelectionIfPresent`.\n */\nexport async function awaitPlayerChoice(store) {\n  // Only wait for the choice here; actual resolution is handled by\n  // resolveSelectionIfPresent() before this call or by the scheduled\n  // guard via guardSelectionResolution().\n  await waitForPlayerChoice(store, 1500);\n}\n\n/**\n * Schedule outcome computation and expose a cancellation guard.\n *\n * @param {object} store\n * @param {object} machine\n * @returns {() => void} cleanup function\n * @pseudocode\n * 1. Schedule guard to run `computeAndDispatchOutcome` after 1200 ms.\n * 2. Save cancel function via `exposeDebugState('roundDecisionGuard')`.\n * 3. Return a cleanup function that clears the guard and nulls the global.\n */\nexport function guardSelectionResolution(store, machine) {\n  const cancel = scheduleGuard(1200, () => computeAndDispatchOutcome(store, machine));\n  exposeDebugState(\"roundDecisionGuard\", cancel);\n  return () => {\n    guard(() => {\n      const fn = readDebugState(\"roundDecisionGuard\");\n      if (typeof fn === \"function\") fn();\n      exposeDebugState(\"roundDecisionGuard\", null);\n    });\n  };\n}\n\n/**\n * Schedule watchdog to ensure state progression after resolution.\n *\n * @param {object} machine\n * @pseudocode\n * 1. After 600 ms, if state is still `roundDecision`, dispatch interrupt with `postResolveWatchdog`.\n */\nexport function schedulePostResolveWatchdog(machine) {\n  setTimeout(() => {\n    guardAsync(async () => {\n      const still = machine.getState ? machine.getState() : null;\n      if (still === \"roundDecision\") {\n        await machine.dispatch(\"interrupt\", { reason: \"postResolveWatchdog\" });\n      }\n    });\n  }, 600);\n}\n\n/**\n * Orchestrate round decision entry by composing small helpers.\n *\n * @param {object} machine\n * @returns {Promise<void>}\n * @pseudocode\n * recordEntry()\n * cancel ← guardSelectionResolution(store, machine)\n * if !resolveSelectionIfPresent(store) → awaitPlayerChoice(store)\n * cancel()\n * schedulePostResolveWatchdog(machine)\n * on timeout → show \"No selection\" and interrupt\n * on other error → handleRoundError(`roundResolutionError`)\n */\nexport async function roundDecisionEnter(machine) {\n  const { store } = machine.context;\n  recordEntry();\n  const cancel = guardSelectionResolution(store, machine);\n  try {\n    const resolved = await resolveSelectionIfPresent(store);\n    if (!resolved) await awaitPlayerChoice(store);\n    cancel();\n    schedulePostResolveWatchdog(machine);\n  } catch (err) {\n    cancel();\n    if (err?.message === \"timeout\") {\n      guard(() =>\n        emitBattleEvent(\"scoreboardShowMessage\", \"No selection detected. Interrupting round.\")\n      );\n      guard(() => emitBattleEvent(\"debugPanelUpdate\"));\n      await guardAsync(() => machine.dispatch(\"interrupt\", { reason: \"noSelection\" }));\n    } else {\n      await handleRoundError(machine, \"roundResolutionError\", err);\n    }\n  }\n}\nexport async function roundDecisionExit() {\n  // Clear any scheduled decision guard to prevent late outcome dispatch.\n  try {\n    const fn = readDebugState(\"roundDecisionGuard\");\n    if (typeof fn === \"function\") fn();\n    exposeDebugState(\"roundDecisionGuard\", null);\n  } catch {}\n}\n\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * onEnter handler for `roundOver` state.\n *\n * @pseudocode\n * 1. Clear any transient selection state from the store so the next round\n *    starts with a clean slate.\n * 2. Return immediately; UI updates are handled elsewhere.\n *\n * @param {object} machine\n */\nexport async function roundOverEnter(machine) {\n  const store = machine?.context?.store;\n  if (store) {\n    store.playerChoice = null;\n    store.selectionMade = false;\n  }\n}\n\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\nexport async function matchDecisionEnter() {}\n\n/**\n * onEnter handler for the `matchOver` state.\n *\n * @pseudocode\n * 1. Emit a `matchOver` battle event so consumers can show restart controls.\n */\nexport async function matchOverEnter() {\n  emitBattleEvent(\"matchOver\");\n}\n\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * onEnter handler for `interruptRound`.\n *\n * @pseudocode\n * 1. Clear scoreboard messages and update debug panel.\n * 2. Clear any pending selection and scheduled guards.\n * 3. Persist the last interrupt reason to `window` for diagnostics.\n * 4. If `payload.adminTest` -> dispatch `roundModification` with payload,\n *    otherwise dispatch `restartRound` to reach cooldown.\n *\n * @param {object} machine\n * @param {object} [payload]\n */\nexport async function interruptRoundEnter(machine, payload) {\n  emitBattleEvent(\"scoreboardClearMessage\");\n  emitBattleEvent(\"debugPanelUpdate\");\n  // Ensure store selection is cleared when an interrupt occurs so leftover\n  // `playerChoice` doesn't persist and block future rounds.\n  try {\n    const store = machine?.context?.store;\n    if (store) {\n      store.playerChoice = null;\n      store.selectionMade = false;\n    }\n    const fn = readDebugState(\"roundDecisionGuard\");\n    if (typeof fn === \"function\") fn();\n    exposeDebugState(\"roundDecisionGuard\", null);\n  } catch {}\n  // Expose the last interrupt reason for diagnostics and tests\n  try {\n    exposeDebugState(\"classicBattleLastInterruptReason\", payload?.reason || \"\");\n  } catch {}\n  if (payload?.reason) {\n    emitBattleEvent(\"scoreboardShowMessage\", `Round interrupted: ${payload.reason}`);\n  }\n  if (payload?.adminTest) {\n    await machine.dispatch(\"roundModification\", payload);\n  } else {\n    // Use the state-table-defined trigger to reach cooldown\n    await machine.dispatch(\"restartRound\");\n  }\n}\n\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * onEnter handler for `interruptMatch`.\n *\n * @pseudocode\n * 1. Clear scoreboard messages and update debug panel.\n * 2. Show an interrupt message when a reason is provided.\n * 3. Trigger the state-table-defined `toLobby` transition with payload.\n *\n * @param {object} machine\n * @param {object} [payload]\n */\nexport async function interruptMatchEnter(machine, payload) {\n  emitBattleEvent(\"scoreboardClearMessage\");\n  emitBattleEvent(\"debugPanelUpdate\");\n  if (payload?.reason) {\n    emitBattleEvent(\"scoreboardShowMessage\", `Match interrupted: ${payload.reason}`);\n  }\n  // Return to lobby via state-table-defined trigger\n  await machine.dispatch(\"toLobby\", payload);\n}\n\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * onEnter handler for `roundModification`.\n *\n * @pseudocode\n * 1. Clear scoreboard messages and update debug panel.\n * 2. If payload.modification -> show a message describing the modification.\n * 3. If payload.resumeRound -> dispatch `roundStart`, else dispatch `cooldown`.\n *\n * @param {object} machine\n * @param {object} [payload]\n */\nexport async function roundModificationEnter(machine, payload) {\n  emitBattleEvent(\"scoreboardClearMessage\");\n  emitBattleEvent(\"debugPanelUpdate\");\n  if (payload?.modification) {\n    emitBattleEvent(\"scoreboardShowMessage\", `Round modified: ${payload.modification}`);\n  }\n  if (payload?.resumeRound) {\n    await machine.dispatch(\"roundStart\");\n  } else {\n    await machine.dispatch(\"cooldown\");\n  }\n}\n\nexport const onEnterHandlers = {\n  waitingForMatchStart: waitingForMatchStartEnter,\n  matchStart: matchStartEnter,\n  cooldown: cooldownEnter,\n  roundStart: roundStartEnter,\n  waitingForPlayerAction: waitingForPlayerActionEnter,\n  roundDecision: roundDecisionEnter,\n  roundOver: roundOverEnter,\n  matchDecision: matchDecisionEnter,\n  matchOver: matchOverEnter,\n  interruptRound: interruptRoundEnter,\n  interruptMatch: interruptMatchEnter,\n  roundModification: roundModificationEnter\n};\n\nexport const onExitHandlers = {\n  waitingForPlayerAction: waitingForPlayerActionExit,\n  roundDecision: roundDecisionExit\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/promises.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/quitButton.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/quitModal.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":38,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createModal } from \"../../components/Modal.js\";\nimport { createButton } from \"../../components/Button.js\";\nimport * as battleEngine from \"../battleEngineFacade.js\";\nimport { showResult } from \"../battle/index.js\";\nimport { getOutcomeMessage } from \"../api/battleUI.js\";\nimport { navigateToHome } from \"../navUtils.js\";\nimport { dispatchBattleEvent } from \"./orchestrator.js\";\nimport { getBattleState } from \"./eventBus.js\";\nimport { t } from \"../i18n.js\";\n\nfunction createQuitConfirmation(store, onConfirm) {\n  const title = document.createElement(\"h2\");\n  title.id = \"quit-modal-title\";\n  title.textContent = t(\"modal.quit.title\") || \"Quit the match?\";\n\n  const desc = document.createElement(\"p\");\n  desc.id = \"quit-modal-desc\";\n  desc.textContent = t(\"modal.quit.desc\") || \"Your progress will be lost.\";\n\n  const actions = document.createElement(\"div\");\n  actions.className = \"modal-actions\";\n\n  const cancel = createButton(t(\"modal.quit.cancel\") || \"Cancel\", {\n    id: \"cancel-quit-button\",\n    className: \"secondary-button\"\n  });\n  const quit = createButton(t(\"modal.quit.confirm\") || \"Quit\", { id: \"confirm-quit-button\" });\n  actions.append(cancel, quit);\n\n  const frag = document.createDocumentFragment();\n  frag.append(title, desc, actions);\n\n  const modal = createModal(frag, { labelledBy: title, describedBy: desc });\n  cancel.addEventListener(\"click\", () => modal.close());\n  quit.addEventListener(\"click\", async () => {\n    try {\n      onConfirm();\n    } catch (e) {\n      // If the engine is not initialized, fall back to showing a quit message\n      // so the UI communicates the action without requiring engine state.\n      try {\n        showResult(getOutcomeMessage(\"quit\"));\n      } catch {}\n    }\n    modal.close();\n    // Drive state machine to interruption path\n    await dispatchBattleEvent(\"interrupt\");\n    const state = getBattleState();\n    if (state === \"interruptMatch\") {\n      await dispatchBattleEvent(\"toLobby\");\n    } else if (state === \"interruptRound\") {\n      await dispatchBattleEvent(\"abortMatch\");\n    }\n    // Navigate to home (robust to varying base paths like GH Pages)\n    modal.destroy();\n    store.quitModal = null;\n    navigateToHome();\n  });\n  document.body.appendChild(modal.element);\n  return modal;\n}\n/**\n * Promise that resolves with the confirm-quit button element when the quit\n * confirmation modal is presented. Tests can await `window.quitConfirmButtonPromise`\n * to interact with the modal's confirm button.\n *\n * @type {Promise<HTMLButtonElement>}\n */\nexport let quitConfirmButtonPromise = Promise.resolve();\n/**\n * Trigger the Classic Battle quit confirmation modal and return the confirm button.\n *\n * Presents a modal asking the player to confirm quitting the match. A Promise\n * is exposed on `window.quitConfirmButtonPromise` so tests can await or act on\n * the confirm button DOM being available.\n *\n * @pseudocode\n * 1. Create a new promise and store it in `quitConfirmButtonPromise` and on window.\n * 2. Create the modal if `store.quitModal` is not already present.\n * 3. Open the modal, focusing the supplied `trigger` element when available.\n * 4. Poll for the confirm button element and resolve the promise once found.\n *\n * @param {ReturnType<typeof createBattleStore>} store - Battle state store.\n * @param {HTMLElement} [trigger] - Element that initiated the quit action.\n * @returns {Promise<HTMLButtonElement>} Resolves with the confirm button element.\n */\nexport function quitMatch(store, trigger) {\n  let resolveBtn;\n  quitConfirmButtonPromise = new Promise((resolve) => {\n    resolveBtn = resolve;\n  });\n  window.quitConfirmButtonPromise = quitConfirmButtonPromise;\n  if (!store.quitModal) {\n    store.quitModal = createQuitConfirmation(store, () => {\n      const result = battleEngine.quitMatch();\n      showResult(getOutcomeMessage(result.outcome));\n    });\n  }\n  const fallback = document.getElementById(\"quit-match-button\");\n  store.quitModal.open(trigger ?? fallback ?? undefined);\n  const check = () => {\n    const btn = document.getElementById(\"confirm-quit-button\");\n    if (btn) resolveBtn(btn);\n    else requestAnimationFrame(check);\n  };\n  check();\n  return quitConfirmButtonPromise;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/roundManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/roundResolver.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/roundSelectModal.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/roundUI.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/selectionHandler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/setupDebugHooks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/setupScheduler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/setupTestHelpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/setupUIBindings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/skipHandler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/statButtons.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/stateManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/stateTable.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/stateTransitionListeners.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/testHooks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/timerService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/uiEventHandlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/uiHelpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/uiService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattle/view.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/classicBattlePage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/constants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/country/codes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/country/list.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/countryPanel.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/countrySlider.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/countryUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/cssVariableParser.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/dataUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/debug.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/displayMode.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/domReady.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/env.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/errorUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/featureFlags.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/gameModeUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/homePage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/i18n.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/inspector/createInspectorPanel.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/judokaUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/judokaValidation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/layoutDebugPanel.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/lazyPortrait.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/markdownToHtml.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/meditationPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/mockupViewerPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/modalManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/motionUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/navUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/navigation/navData.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/navigation/navMenu.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/navigation/navigationService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/navigation/navigationUI.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/navigationBar.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/navigationCache.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/opponentCardWait.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/orientation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/prdReaderPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/prdTaskStats.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/preload.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/pseudoJapanese/converter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/pseudoJapanese/ui.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/queryRag.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/quoteBuilder.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/quotes/quoteRenderer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/quotes/quoteService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/randomCard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/randomCardService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/randomJudokaPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/sanitizeHtml.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/scheduler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/seedRandom.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/addNavResetButton.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/applyInitialValues.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/attachResetListener.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/createResetModal.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/featureFlagSwitches.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/gameModeSwitches.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/listenerUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/makeHandleUpdate.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/renderFeatureFlags.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/renderGameModes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/renderNavCacheReset.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/syncDisplayMode.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settings/syncFeatureFlags.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settingsCache.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settingsPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settingsStorage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/settingsUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/setupBottomNavbar.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/setupClassicBattleHomeLink.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/setupDisplaySettings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/setupHoverZoom.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/setupScoreboard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/setupSvgFallback.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/showSettingsError.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/showSnackbar.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/signatureMove.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/snippetFormatter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/stats.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/storage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/svgFallback.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/telemetry.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/testModeUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/timerUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/timers/computeNextRoundCooldown.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/timers/createRoundTimer.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":58,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { startCoolDown, stopTimer } from \"../battleEngineFacade.js\";\n\n/**\n * Create a round timer that emits tick, drift, and expiration events.\n *\n * @pseudocode\n * 1. Register listeners for `tick`, `expired`, and `drift` events.\n * 2. Start underlying engine timer via `starter` with internal handlers.\n * 3. On each tick, emit `tick(remaining)`.\n * 4. On drift, emit `drift(remaining)` and retry up to 3 times; on failure call `onDriftFail` or expire.\n * 5. On expiration or manual stop, emit `expired` once.\n *\n * @param {{\n *   starter?: (\n *     onTick: (remaining: number) => void,\n *     onExpired: () => void,\n *     dur: number,\n *     onDrift: (remaining: number) => void\n *   ) => void | Promise<void>,\n *   onDriftFail?: () => Promise<void> | void\n * }} [opts]\n * @returns {{\n *   start: (dur: number) => void | Promise<void>,\n *   stop: () => void,\n *   on: (event: \"tick\" | \"expired\" | \"drift\", handler: Function) => () => void,\n *   off: (event: \"tick\" | \"expired\" | \"drift\", handler: Function) => void\n * }}\n */\nexport function createRoundTimer({ starter = startCoolDown, onDriftFail } = {}) {\n  const MAX_DRIFT_RETRIES = 3;\n  const listeners = {\n    tick: new Set(),\n    expired: new Set(),\n    drift: new Set()\n  };\n  let retries = 0;\n\n  function emit(event, payload) {\n    for (const fn of listeners[event]) {\n      try {\n        fn(payload);\n      } catch {}\n    }\n  }\n\n  function on(event, handler) {\n    listeners[event].add(handler);\n    return () => off(event, handler);\n  }\n\n  function off(event, handler) {\n    listeners[event].delete(handler);\n  }\n\n  function start(dur) {\n    try {\n      return starter(emitTick, emitExpired, dur, handleDrift);\n    } catch (e) {\n      // Fallback when the engine is not initialized: run a simple JS timer\n      // that emits tick events every second and expires after `dur` seconds.\n      // This keeps UI behavior and tests working without requiring engine setup.\n      const total = Number(dur) || 0;\n      if (total <= 0) {\n        return emitExpired();\n      }\n      let remaining = Math.ceil(total);\n      emitTick(remaining);\n      const intervalId = setInterval(() => {\n        remaining -= 1;\n        if (remaining > 0) {\n          emitTick(remaining);\n        } else {\n          clearInterval(intervalId);\n          emitExpired();\n        }\n      }, 1000);\n    }\n  }\n\n  function emitTick(remaining) {\n    emit(\"tick\", remaining);\n  }\n\n  async function emitExpired() {\n    emit(\"expired\");\n  }\n\n  async function handleDrift(remaining) {\n    retries += 1;\n    if (retries > MAX_DRIFT_RETRIES) {\n      if (typeof onDriftFail === \"function\") {\n        await onDriftFail();\n      } else {\n        await emitExpired();\n      }\n      return;\n    }\n    emit(\"drift\", remaining);\n    await start(remaining);\n  }\n\n  function stop() {\n    try {\n      stopTimer();\n    } catch {}\n    emitExpired();\n  }\n\n  return { start, stop, on, off };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/tooltip.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/tooltipOverlayDebug.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/tooltipViewer/extractLineAndColumn.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/tooltipViewer/renderList.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/tooltipViewerPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/typewriter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearch/chunkConfig.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearch/context.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearch/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearch/loader.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearch/scorer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearchPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearchPage/queryUi.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearchPage/renderResults.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearchPage/renderUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/vectorSearchQuery.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/viewTransition.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/helpers/viewportDebug.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/pages/battleCLI.init.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/pages/battleCLI.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'selectionFinishFn' is assigned a value but never used.","line":105,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Classic Battle CLI bootstrap and controller\n// Wires the existing Classic Battle engine/state machine to a terminal-style UI.\n\nimport {\n  createBattleStore,\n  startRound as startRoundCore,\n  resetGame\n} from \"../helpers/classicBattle/roundManager.js\";\nimport * as battleOrchestrator from \"../helpers/classicBattle/orchestrator.js\";\nimport { onBattleEvent, emitBattleEvent } from \"../helpers/classicBattle/battleEvents.js\";\nimport { STATS } from \"../helpers/BattleEngine.js\";\nimport * as engineFacade from \"../helpers/battleEngineFacade.js\";\nimport statNamesData from \"../data/statNames.js\";\nimport { createModal } from \"../components/Modal.js\";\nimport { createButton } from \"../components/Button.js\";\nimport {\n  initFeatureFlags,\n  isEnabled,\n  setFlag,\n  featureFlagsEmitter\n} from \"../helpers/featureFlags.js\";\nimport {\n  skipRoundCooldownIfEnabled,\n  updateBattleStateBadge\n} from \"../helpers/classicBattle/uiHelpers.js\";\nimport { getStateSnapshot } from \"../helpers/classicBattle/battleDebug.js\";\nimport { autoSelectStat } from \"../helpers/classicBattle/autoSelectStat.js\";\nimport { createRoundTimer } from \"../helpers/timers/createRoundTimer.js\";\nimport { setTestMode } from \"../helpers/testModeUtils.js\";\nimport { wrap } from \"../helpers/storage.js\";\nimport { BATTLE_POINTS_TO_WIN } from \"../config/storageKeys.js\";\nimport { POINTS_TO_WIN_OPTIONS } from \"../config/battleDefaults.js\";\nimport * as debugHooks from \"../helpers/classicBattle/debugHooks.js\";\nimport { setAutoContinue, autoContinue } from \"../helpers/classicBattle/orchestratorHandlers.js\";\nimport { SNACKBAR_REMOVE_MS } from \"../helpers/constants.js\";\nimport { registerModal, unregisterModal, onEsc } from \"../helpers/modalManager.js\";\n\n// Initialize engine and subscribe to engine events when available.\ntry {\n  if (!window.__TEST__ && typeof engineFacade.createBattleEngine === \"function\") {\n    engineFacade.createBattleEngine();\n  }\n} catch {}\n\n// Engine event wiring is installed during init() to avoid touching mocked\n// module exports during unit tests that import this module.\n\nfunction disposeClassicBattleOrchestrator() {\n  try {\n    battleOrchestrator?.disposeClassicBattleOrchestrator?.();\n  } catch {\n    /* ignore: orchestrator may not be initialized */\n  }\n}\n\n/**\n * Safely dispatch an event to the classic battle machine.\n *\n * @pseudocode\n * 1. Try debugHooks channel first to get the live machine and call `dispatch`.\n * 2. Fallback to orchestrator's `dispatchBattleEvent` if available (when not mocked).\n * 3. Swallow any errors to keep CLI responsive during tests.\n */\nasync function safeDispatch(eventName, payload) {\n  try {\n    const getter = debugHooks?.readDebugState?.(\"getClassicBattleMachine\");\n    const m = typeof getter === \"function\" ? getter() : getter;\n    if (m?.dispatch) {\n      return payload === undefined\n        ? await m.dispatch(eventName)\n        : await m.dispatch(eventName, payload);\n    }\n  } catch {}\n  try {\n    const fn = battleOrchestrator?.dispatchBattleEvent;\n    if (typeof fn === \"function\") {\n      return payload === undefined ? await fn(eventName) : await fn(eventName, payload);\n    }\n  } catch {}\n}\n\n/**\n * Minimal DOM utils for the CLI page\n */\nconst byId = (id) => document.getElementById(id);\n\nfunction getMachine() {\n  try {\n    // Prefer debugHooks channel used by tests\n    const getter = debugHooks?.readDebugState?.(\"getClassicBattleMachine\");\n    const m = typeof getter === \"function\" ? getter() : getter;\n    if (m) return m;\n  } catch {}\n  return null;\n}\n\n// Track current round judoka so we can compute values without card DOM\nlet currentPlayerJudoka = null;\nlet store = null;\nlet verboseEnabled = false;\nlet cooldownTimer = null;\nlet cooldownInterval = null;\nlet selectionTimer = null;\nlet selectionInterval = null;\nlet selectionFinishFn = null;\nlet selectionTickHandler = null;\nlet selectionExpiredHandler = null;\nlet selectionCancelled = false;\nlet quitModal = null;\nlet isQuitting = false;\nlet pausedSelectionRemaining = null;\nlet pausedCooldownRemaining = null;\nlet ignoreNextAdvanceClick = false;\nlet roundResolving = false;\nlet shortcutsReturnFocus = null;\nlet shortcutsOverlay = null;\nlet escapeHandledResolve;\nlet escapeHandledPromise = new Promise((r) => {\n  escapeHandledResolve = r;\n});\n\n/**\n * Return a promise that resolves after the Escape key is handled.\n *\n * @pseudocode\n * return current `escapeHandledPromise`\n * @returns {Promise<void>} promise resolving when Escape logic finishes\n */\nexport function getEscapeHandledPromise() {\n  return escapeHandledPromise;\n}\n\n/**\n * Resolve any pending Escape promise and create a new one.\n *\n * @pseudocode\n * IF `escapeHandledResolve` exists\n *   call `escapeHandledResolve`\n * ENDIF\n * create new promise assigning resolver to `escapeHandledResolve`\n */\nfunction resolveEscapeHandled() {\n  try {\n    escapeHandledResolve?.();\n  } catch {\n    // Ignore if previous promise already settled\n  }\n  escapeHandledPromise = new Promise((r) => {\n    escapeHandledResolve = r;\n  });\n}\n\nonEsc(resolveEscapeHandled);\n\ntry {\n  window.__battleCLIinit = Object.assign(window.__battleCLIinit || {}, {\n    getEscapeHandledPromise\n  });\n} catch {\n  // Ignore in non-browser environments where `window` is undefined\n}\nconst statDisplayNames = {};\nlet cachedStatDefs = null;\n\n// Test hooks to access internal timer state\nexport const __test = {\n  setCooldownTimers(timer, interval) {\n    cooldownTimer = timer;\n    cooldownInterval = interval;\n  },\n  getCooldownTimers() {\n    return { cooldownTimer, cooldownInterval };\n  },\n  setSelectionTimers(timer, interval) {\n    selectionTimer = timer;\n    selectionInterval = interval;\n  },\n  getSelectionTimers() {\n    return { selectionTimer, selectionInterval };\n  },\n  async forceSelectionExpiry() {\n    try {\n      // Directly simulate expiry to make tests deterministic\n      if (isEnabled(\"autoSelect\")) {\n        await autoSelectStat(selectStat);\n      } else {\n        emitBattleEvent(\"statSelectionStalled\");\n      }\n    } catch {}\n  },\n  installEventBindings,\n  autostartBattle,\n  renderStatList,\n  restorePointsToWin,\n  startRoundWrapper,\n  // Expose init for tests to manually initialize without DOMContentLoaded\n  init,\n  handleScoreboardShowMessage,\n  handleScoreboardClearMessage,\n  handleStatSelectionStalled,\n  handleCountdownStart,\n  handleCountdownFinished,\n  handleRoundResolved,\n  handleMatchOver,\n  handleBattleState,\n  onKeyDown\n};\n/**\n * Update the round counter line in the header.\n *\n * @pseudocode\n * if round element exists:\n *   set text to `Round ${round} Target: ${target}`\n * if root exists:\n *   set `data-round` and `data-target`\n */\nfunction updateRoundHeader(round, target) {\n  const el = byId(\"cli-round\");\n  if (el) el.textContent = `Round ${round} Target: ${target} 🏆`;\n  const root = byId(\"cli-root\");\n  if (root) {\n    root.dataset.round = String(round);\n    root.dataset.target = String(target);\n  }\n}\n\nfunction setRoundMessage(text) {\n  const el = byId(\"round-message\");\n  if (el) el.textContent = text || \"\";\n}\n\nfunction updateScoreLine() {\n  const { playerScore, opponentScore } = engineFacade.getScores?.() || {\n    playerScore: 0,\n    opponentScore: 0\n  };\n  const el = byId(\"cli-score\");\n  if (el) {\n    el.textContent = `You: ${playerScore} Opponent: ${opponentScore}`;\n    el.dataset.scorePlayer = String(playerScore);\n    el.dataset.scoreOpponent = String(opponentScore);\n  }\n}\n\n/**\n * Clear the verbose log output.\n *\n * @pseudocode\n * el = document.getElementById(\"cli-verbose-log\")\n * if el exists:\n *   set textContent to \"\"\n */\nfunction clearVerboseLog() {\n  const el = byId(\"cli-verbose-log\");\n  if (el) el.textContent = \"\";\n}\n\n/**\n * Reset the match and reinitialize the battle orchestrator.\n *\n * @pseudocode\n * stopSelectionCountdown()\n * handleCountdownFinished()\n * roundResolving = false\n * clearVerboseLog()\n * remove play-again/start buttons\n * resetPromise = async () => {\n *   disposeClassicBattleOrchestrator()\n *   await resetGame(store)\n *   updateRoundHeader(0, engineFacade.getPointsToWin?.())\n *   updateScoreLine()\n *   setRoundMessage(\"\")\n *   await initClassicBattleOrchestrator(store, startRoundWrapper)\n * }\n * await resetPromise\n */\nlet resetPromise = Promise.resolve();\nasync function resetMatch() {\n  stopSelectionCountdown();\n  handleCountdownFinished();\n  roundResolving = false;\n  clearVerboseLog();\n  try {\n    document.getElementById(\"play-again-button\")?.remove();\n    document.getElementById(\"start-match-button\")?.remove();\n  } catch {}\n  // Perform synchronous reset work and kick orchestrator init asynchronously\n  const next = (async () => {\n    disposeClassicBattleOrchestrator();\n    await resetGame(store);\n    updateRoundHeader(0, engineFacade.getPointsToWin?.());\n    updateScoreLine();\n    setRoundMessage(\"\");\n    // Initialize orchestrator in the background to avoid hanging under fake timers in tests.\n    try {\n      const p = battleOrchestrator.initClassicBattleOrchestrator?.(store, startRoundWrapper);\n      // Do not await here; allow caller to proceed and render Start button.\n      void p;\n    } catch {}\n  })();\n  resetPromise = next;\n  await next;\n}\n\n/**\n * Render the Start button after the orchestrator reset completes.\n *\n * @pseudocode\n * await resetPromise\n * if main missing or button exists → return\n * create section + button\n * on click → emit \"startClicked\" and dispatch to machine\n * remove section\n */\nasync function renderStartButton() {\n  await resetPromise;\n  const main = byId(\"cli-main\");\n  if (!main || byId(\"start-match-button\")) return;\n  const section = document.createElement(\"section\");\n  section.className = \"cli-block\";\n  const btn = createButton(\"Start match\", {\n    id: \"start-match-button\",\n    className: \"primary-button\"\n  });\n  btn.addEventListener(\"click\", () => {\n    try {\n      // Notify UI/event listeners that start was clicked\n      emitBattleEvent(\"startClicked\");\n    } catch {}\n    try {\n      const getter = debugHooks.readDebugState(\"getClassicBattleMachine\");\n      const machine = typeof getter === \"function\" ? getter() : getter;\n      if (machine) machine.dispatch(\"startClicked\");\n      else if (typeof window !== \"undefined\" && window.__TEST__) {\n        // Test fallback: in fake-timer environments where the orchestrator init is mocked\n        // and not advanced, simulate the post-start transition so countdown can begin.\n        try {\n          emitBattleEvent(\"battleStateChange\", { to: \"waitingForPlayerAction\" });\n        } catch {}\n      }\n    } catch (err) {\n      console.debug(\"Failed to dispatch startClicked\", err);\n    }\n    section.remove();\n  });\n  section.append(btn);\n  main.append(section);\n}\n\n/**\n * Initialize deterministic seed input and validation.\n *\n * @pseudocode\n * read seed query param and localStorage\n * define apply(n): enable test mode and persist n\n * if query param numeric: apply and set input\n * else if stored seed numeric: populate input\n * lastValid <- numeric seed used or stored\n * on input change:\n *   if value is NaN:\n *     revert to lastValid and show error\n *   else:\n *     clear error, apply value, update lastValid\n */\nfunction initSeed() {\n  const input = byId(\"seed-input\");\n  const errorEl = byId(\"seed-error\");\n  let seedParam = null;\n  let storedSeed = null;\n  try {\n    const params = new URLSearchParams(window.location.search);\n    seedParam = params.get(\"seed\");\n    storedSeed = localStorage.getItem(\"battleCLI.seed\");\n  } catch {}\n  const apply = (n) => {\n    setTestMode({ enabled: true, seed: n });\n    try {\n      localStorage.setItem(\"battleCLI.seed\", String(n));\n    } catch {}\n  };\n  let lastValid = null;\n  // Only auto-enable test mode when an explicit seed query param is provided.\n  if (seedParam !== null && seedParam !== \"\") {\n    const num = Number(seedParam);\n    if (!Number.isNaN(num)) {\n      apply(num);\n      if (input) input.value = String(num);\n      lastValid = num;\n    }\n  } else if (storedSeed) {\n    const num = Number(storedSeed);\n    if (!Number.isNaN(num)) {\n      // Populate the input from previous choice without enabling test mode implicitly.\n      if (input) input.value = String(num);\n      lastValid = num;\n    }\n  }\n  input?.addEventListener(\"change\", () => {\n    const val = Number(input.value);\n    if (input.value.trim() === \"\" || Number.isNaN(val)) {\n      if (lastValid !== null) {\n        input.value = String(lastValid);\n      } else {\n        input.value = \"\";\n      }\n      if (errorEl) errorEl.textContent = \"Seed must be numeric and non-empty.\";\n      return;\n    }\n    if (errorEl) errorEl.textContent = \"\";\n    apply(val);\n    lastValid = val;\n  });\n}\n\n/**\n * Show or hide the battle state badge based on feature flag.\n *\n * @pseudocode\n * if badge element exists:\n *   set hidden to !isEnabled(\"battleStateBadge\")\n */\nfunction updateStateBadgeVisibility() {\n  const badge = byId(\"battle-state-badge\");\n  if (badge) badge.style.display = isEnabled(\"battleStateBadge\") ? \"\" : \"none\";\n}\n\n/**\n * Show or hide the CLI shortcuts section based on feature flag.\n *\n * @pseudocode\n * if shortcuts section exists:\n *   set hidden to !isEnabled(\"cliShortcuts\")\n */\nfunction updateCliShortcutsVisibility() {\n  const section = byId(\"cli-shortcuts\");\n  if (!section) return;\n  if (!isEnabled(\"cliShortcuts\")) {\n    section.hidden = true;\n    section.style.display = \"none\";\n  } else {\n    section.style.display = \"\";\n    section.hidden = true;\n  }\n}\n\n/**\n * Expand the CLI shortcuts panel.\n *\n * @pseudocode\n * if test hook `setShortcutsCollapsed(false)` returns false:\n *   show shortcuts section and body\n *   persist expanded state to localStorage\n *   set close button `aria-expanded` to true\n */\nfunction showCliShortcuts() {\n  if (!window.__battleCLIinit?.setShortcutsCollapsed?.(false)) {\n    const body = byId(\"cli-shortcuts-body\");\n    const sec = byId(\"cli-shortcuts\");\n    const close = byId(\"cli-shortcuts-close\");\n    try {\n      localStorage.setItem(\"battleCLI.shortcutsCollapsed\", \"0\");\n    } catch {}\n    if (body) body.style.display = \"\";\n    sec?.removeAttribute(\"hidden\");\n    close?.setAttribute(\"aria-expanded\", \"true\");\n    shortcutsOverlay = { close: hideCliShortcuts };\n    registerModal(shortcutsOverlay);\n  }\n}\n\n/**\n * Collapse the CLI shortcuts panel and restore focus.\n *\n * @pseudocode\n * if test hook `setShortcutsCollapsed(true)` returns false:\n *   hide shortcuts section and body\n *   persist collapsed state to localStorage\n *   set close button `aria-expanded` to false\n * if stored focus exists: focus it and clear reference\n */\nfunction hideCliShortcuts() {\n  if (!window.__battleCLIinit?.setShortcutsCollapsed?.(true)) {\n    const body = byId(\"cli-shortcuts-body\");\n    const sec = byId(\"cli-shortcuts\");\n    const close = byId(\"cli-shortcuts-close\");\n    try {\n      localStorage.setItem(\"battleCLI.shortcutsCollapsed\", \"1\");\n    } catch {}\n    if (body) body.style.display = \"none\";\n    if (sec) sec.setAttribute(\"hidden\", \"\");\n    close?.setAttribute(\"aria-expanded\", \"false\");\n  }\n  try {\n    shortcutsReturnFocus?.focus();\n  } catch {}\n  shortcutsReturnFocus = null;\n  if (shortcutsOverlay) {\n    unregisterModal(shortcutsOverlay);\n    shortcutsOverlay = null;\n  }\n}\n\nfunction showBottomLine(text) {\n  // Render as a single bottom line using the snackbar container\n  try {\n    // Lazily create a minimal snackbar child if missing\n    const container = byId(\"snackbar-container\");\n    if (!container) return;\n    let bar = container.querySelector(\".snackbar\");\n    if (!bar) {\n      bar = document.createElement(\"div\");\n      bar.className = \"snackbar\";\n      container.appendChild(bar);\n    }\n    bar.setAttribute(\"tabindex\", \"0\");\n    bar.textContent = text || \"\";\n    // Move focus to the prompt when showing actionable guidance so\n    // screen-reader and keyboard users are directed appropriately.\n    if (text) {\n      try {\n        bar.focus();\n      } catch {}\n    }\n  } catch {}\n}\n\n/**\n * Sanitize snackbar hint text to avoid DOM injection.\n *\n * @param {unknown} text\n * @returns {string}\n * @pseudocode\n * if text not string: return \"\"\n * return text stripped of non-printable characters and trimmed to 200 chars\n */\nfunction sanitizeHintText(text) {\n  if (typeof text !== \"string\") return \"\";\n  return text.replace(/[^\\x20-\\x7E\\u00A0-\\uFFFF]/g, \"\").slice(0, 200);\n}\n\n/**\n * Display a short-lived snackbar hint without clearing the countdown.\n *\n * @pseudocode\n * container = document.getElementById(\"snackbar-container\")\n * if container missing: return\n * create div.snackbar.show with sanitized message\n * append to container\n * timeoutId = setTimeout(remove bar, SNACKBAR_REMOVE_MS)\n * store timeoutId on bar\n * observe container for bar removal and clear timeout\n *\n * @param {string} text - Hint text to display.\n */\nfunction showHint(text) {\n  const container = byId(\"snackbar-container\");\n  if (!container) return;\n  const bar = document.createElement(\"div\");\n  bar.className = \"snackbar show\";\n  bar.textContent = sanitizeHintText(text);\n  container.appendChild(bar);\n  const timeoutId = setTimeout(() => {\n    if (bar && bar.parentNode) {\n      bar.remove();\n    }\n  }, SNACKBAR_REMOVE_MS);\n  // Store timeout on element to clean up if removed early\n  bar._removeTimeoutId = timeoutId;\n  // Use MutationObserver to detect removal of the snackbar bar\n  const observer = new MutationObserver((mutationsList) => {\n    for (const mutation of mutationsList) {\n      for (const removedNode of mutation.removedNodes) {\n        if (removedNode === bar) {\n          clearTimeout(bar._removeTimeoutId);\n          observer.disconnect();\n          return;\n        }\n      }\n    }\n  });\n  observer.observe(container, { childList: true });\n}\n\n/**\n * Ensure a container exists for modal dialogs.\n *\n * @pseudocode\n * el = document.getElementById(\"modal-container\")\n * if el missing:\n *   create div#modal-container and append to body\n * return el\n *\n * @returns {HTMLElement} Modal container element.\n */\nfunction ensureModalContainer() {\n  let el = byId(\"modal-container\");\n  if (!el) {\n    el = document.createElement(\"div\");\n    el.id = \"modal-container\";\n    document.body.appendChild(el);\n  }\n  return el;\n}\n\n/**\n * Pause active selection and cooldown timers, preserving remaining time.\n *\n * @pseudocode\n * countdownEl = #cli-countdown\n * if selection timers exist:\n *   clear them and store remaining time from countdown dataset\n * if cooldown timers exist:\n *   clear them and parse remaining time from snackbar\n */\nfunction pauseTimers() {\n  const countdown = byId(\"cli-countdown\");\n  if (selectionTimer || selectionInterval) {\n    try {\n      if (selectionTimer) clearTimeout(selectionTimer);\n    } catch {}\n    try {\n      if (selectionInterval) clearInterval(selectionInterval);\n    } catch {}\n    pausedSelectionRemaining = Number(countdown?.dataset?.remainingTime) || null;\n    selectionTimer = null;\n    selectionInterval = null;\n  }\n  const bar = byId(\"snackbar-container\")?.querySelector(\".snackbar\");\n  if (cooldownTimer || cooldownInterval) {\n    try {\n      if (cooldownTimer) clearTimeout(cooldownTimer);\n    } catch {}\n    try {\n      if (cooldownInterval) clearInterval(cooldownInterval);\n    } catch {}\n    const match = bar?.textContent?.match(/Next round in: (\\d+)/);\n    pausedCooldownRemaining = match ? Number(match[1]) : null;\n    cooldownTimer = null;\n    cooldownInterval = null;\n  }\n}\n\n/**\n * Resume timers previously paused by `pauseTimers`.\n *\n * @pseudocode\n * if in waitingForPlayerAction and have selection remaining:\n *   startSelectionCountdown(remaining)\n * if in cooldown and have cooldown remaining:\n *   show bottom line and start interval/timeout\n * reset stored remaining values\n */\nfunction resumeTimers() {\n  if (\n    document.body?.dataset?.battleState === \"waitingForPlayerAction\" &&\n    pausedSelectionRemaining\n  ) {\n    startSelectionCountdown(pausedSelectionRemaining);\n  }\n  if (document.body?.dataset?.battleState === \"cooldown\" && pausedCooldownRemaining) {\n    let remaining = pausedCooldownRemaining;\n    showBottomLine(`Next round in: ${remaining}`);\n    try {\n      cooldownInterval = setInterval(() => {\n        remaining -= 1;\n        if (remaining > 0) showBottomLine(`Next round in: ${remaining}`);\n      }, 1000);\n    } catch {}\n    try {\n      cooldownTimer = setTimeout(() => {\n        try {\n          emitBattleEvent(\"countdownFinished\");\n        } catch {}\n      }, remaining * 1000);\n    } catch {}\n  }\n  pausedSelectionRemaining = null;\n  pausedCooldownRemaining = null;\n}\n\n/**\n * Build and display a quit confirmation modal.\n *\n * @pseudocode\n * pauseTimers()\n * if modal not yet created:\n *   build modal with Cancel and Quit buttons\n *   listen for modal 'close' to resume timers when not quitting\n *   cancel closes modal\n *   quit sets quitting flag, dispatches interrupt and clears bottom line\n *   after interrupt resolves: navigate to lobby\n *   append modal to container\n * open modal\n */\nfunction showQuitModal() {\n  pauseTimers();\n  isQuitting = false;\n  if (!quitModal) {\n    const title = document.createElement(\"h2\");\n    title.id = \"quit-modal-title\";\n    title.textContent = \"Quit the match?\";\n\n    const actions = document.createElement(\"div\");\n    actions.className = \"modal-actions\";\n\n    const cancel = createButton(\"Cancel\", {\n      id: \"cancel-quit-button\",\n      className: \"secondary-button\"\n    });\n    const quit = createButton(\"Quit\", { id: \"confirm-quit-button\" });\n    actions.append(cancel, quit);\n\n    const frag = document.createDocumentFragment();\n    frag.append(title, actions);\n\n    quitModal = createModal(frag, { labelledBy: title });\n    quitModal.element.addEventListener(\"close\", () => {\n      if (!isQuitting) resumeTimers();\n    });\n    cancel.addEventListener(\"click\", () => {\n      quitModal.close();\n    });\n    quit.addEventListener(\"click\", async () => {\n      isQuitting = true;\n      quitModal.close();\n      clearBottomLine();\n      try {\n        await safeDispatch(\"interrupt\", { reason: \"quit\" });\n      } catch {}\n      try {\n        // Use a relative path so deployments under a subpath (e.g. GitHub Pages)\n        // navigate back to the lobby correctly.\n        window.location.href = \"../../index.html\";\n      } catch {}\n    });\n    ensureModalContainer().appendChild(quitModal.element);\n  }\n  quitModal.open();\n}\n\nfunction clearBottomLine() {\n  showBottomLine(\"\");\n}\n\n/**\n * Clear active stat selection countdown timers and reset the countdown UI.\n *\n * @pseudocode\n * if timer exists: clearTimeout(timer)\n * if interval exists: clearInterval(interval)\n * null timers and remove countdown text/attribute\n */\nfunction stopSelectionCountdown() {\n  // Prefer silent cancel path for roundTimer-based countdown\n  try {\n    selectionCancelled = true;\n    if (selectionTimer && typeof selectionTimer.off === \"function\") {\n      if (selectionTickHandler) selectionTimer.off(\"tick\", selectionTickHandler);\n      if (selectionExpiredHandler) selectionTimer.off(\"expired\", selectionExpiredHandler);\n    }\n  } catch {}\n  // Legacy clears for fallback paths\n  try {\n    if (selectionTimer && typeof selectionTimer === \"number\") clearTimeout(selectionTimer);\n  } catch {}\n  try {\n    if (selectionInterval) clearInterval(selectionInterval);\n  } catch {}\n  selectionTimer = null;\n  selectionInterval = null;\n  const el = byId(\"cli-countdown\");\n  if (el) {\n    el.textContent = \"\";\n    delete el.dataset.remainingTime;\n  }\n}\n\n/**\n * Clear a timer stored on the given object.\n *\n * @param {object} store\n * @param {string} timerProperty\n * @pseudocode\n * if store?[timerProperty]\n *   try clearTimeout and clearInterval on store[timerProperty]\n *   catch log error\n * set store[timerProperty] = null\n */\nfunction clearStoreTimer(store, timerProperty) {\n  if (!store) return;\n  try {\n    const timerId = store[timerProperty];\n    if (timerId) {\n      clearTimeout(timerId);\n      clearInterval(timerId);\n    }\n  } catch (err) {\n    console.error(`Failed to clear ${timerProperty}`, err);\n  }\n  store[timerProperty] = null;\n}\n\n/**\n * Apply the chosen stat and notify the state machine.\n *\n * @pseudocode\n * stopSelectionCountdown()\n * clear pending selection timers and auto-select callbacks\n * highlight chosen stat\n * update store with selection\n * show bottom line with picked stat\n * set `roundResolving`\n * dispatch \"statSelected\" on machine\n */\nfunction selectStat(stat) {\n  if (!stat) return;\n  stopSelectionCountdown();\n  clearStoreTimer(store, \"statTimeoutId\");\n  clearStoreTimer(store, \"autoSelectId\");\n  const list = byId(\"cli-stats\");\n  list?.querySelectorAll(\".selected\").forEach((el) => el.classList.remove(\"selected\"));\n  const idx = STATS.indexOf(stat) + 1;\n  if (list) list.dataset.selectedIndex = String(idx);\n  const choiceEl = list?.querySelector(`[data-stat-index=\"${idx}\"]`);\n  choiceEl?.classList.add(\"selected\");\n  try {\n    if (store) {\n      store.playerChoice = stat;\n      store.selectionMade = true;\n    }\n  } catch (err) {\n    console.error(\"Failed to update player choice\", err);\n  }\n  showBottomLine(`You Picked: ${stat.charAt(0).toUpperCase()}${stat.slice(1)}`);\n  try {\n    roundResolving = true;\n    safeDispatch(\"statSelected\");\n  } catch (err) {\n    console.error(\"Error dispatching statSelected\", err);\n  }\n}\n\n/**\n * Start a countdown for stat selection and handle expiry.\n *\n * @param {number} [seconds=5]\n * @pseudocode\n * stopSelectionCountdown()\n * set remaining=seconds and update countdown element\n * every 1s: decrement remaining and update element\n * after seconds: stop countdown and\n *   if autoSelect enabled: autoSelectStat(selectStat)\n *   else emit \"statSelectionStalled\"\n */\nfunction startSelectionCountdown(seconds = 30) {\n  const el = byId(\"cli-countdown\");\n  if (!el) return;\n  stopSelectionCountdown();\n  let remaining = seconds;\n  const finish = async () => {\n    if (selectionCancelled) return;\n    // Clear UI and cancel any residual listeners\n    stopSelectionCountdown();\n    try {\n      if (isEnabled(\"autoSelect\")) {\n        await autoSelectStat(selectStat);\n      } else {\n        emitBattleEvent(\"statSelectionStalled\");\n      }\n    } catch {}\n  };\n  selectionFinishFn = finish;\n  // Render initial\n  if (window.__battleCLIinit?.setCountdown) window.__battleCLIinit.setCountdown(remaining);\n  else {\n    el.dataset.remainingTime = String(remaining);\n    el.textContent = `Time remaining: ${remaining}`;\n  }\n  // Create and wire a round timer so tests behave consistently\n  try {\n    const timer = createRoundTimer();\n    selectionCancelled = false;\n    // We don't rely on timer tick for UI; maintain a local interval for deterministic updates\n    selectionTickHandler = null;\n    selectionExpiredHandler = () => {\n      if (selectionCancelled) return;\n      finish();\n    };\n    timer.on(\"expired\", selectionExpiredHandler);\n    selectionTimer = timer;\n    timer.start(remaining);\n    // Mirror countdown UI via JS interval for reliability in tests\n    selectionInterval = setInterval(() => {\n      if (selectionCancelled) return;\n      remaining -= 1;\n      if (remaining > 0) {\n        if (window.__battleCLIinit?.setCountdown) window.__battleCLIinit.setCountdown(remaining);\n        else {\n          el.dataset.remainingTime = String(remaining);\n          el.textContent = `Time remaining: ${remaining}`;\n        }\n      }\n    }, 1000);\n  } catch {\n    // As a last resort, run finish to avoid stalling\n    finish();\n  }\n}\n\n/**\n * Auto-start the battle when the URL indicates `autostart=1`.\n *\n * @pseudocode\n * 1. Ensure `autostart=1` is present in the URL to persist intent.\n * 2. If present, dispatch `startClicked` on the battle machine.\n *\n * @returns {void}\n */\nexport function autostartBattle() {\n  // Persist `autostart=1` so the CLI skips the modal\n  try {\n    const url = new URL(window.location.href);\n    if (url.searchParams.get(\"autostart\") !== \"1\") {\n      url.searchParams.set(\"autostart\", \"1\");\n      history.replaceState({}, \"\", url);\n    }\n  } catch {}\n  // Dispatch start automatically when autostart is enabled\n  try {\n    const autostart = new URLSearchParams(location.search).get(\"autostart\");\n    if (autostart === \"1\") {\n      try {\n        safeDispatch(\"startClicked\");\n      } catch {}\n    }\n  } catch {}\n}\n\n/**\n * Activate a stat row and update roving focus.\n *\n * @pseudocode\n * 1. Retrieve `#cli-stats`; abort if list or row missing.\n * 2. Set `tabIndex` 0 on the row and -1 on others.\n * 3. Ensure the row has an `id` and mirror it to `aria-activedescendant`.\n * 4. Focus the row when `focus` is true.\n *\n * @param {HTMLElement} row - The stat row to activate.\n * @param {object} [options] - Options for activation.\n * @param {boolean} [options.focus=true] - Whether to move focus to the row.\n * @returns {void}\n */\nfunction setActiveStatRow(row, { focus = true } = {}) {\n  const list = byId(\"cli-stats\");\n  if (!list || !row) return;\n  const rows = Array.from(list.querySelectorAll(\".cli-stat\"));\n  rows.forEach((el) => {\n    el.tabIndex = el === row ? 0 : -1;\n  });\n  if (!row.id) {\n    row.id = `cli-stat-${row.dataset.statIndex || rows.indexOf(row) + 1}`;\n  }\n  list.setAttribute(\"aria-activedescendant\", row.id);\n  if (focus) row.focus();\n}\n\n/**\n * Handle arrow-key navigation within the stat list.\n *\n * @pseudocode\n * 1. Collect all stat rows; bail if none exist.\n * 2. Determine the current row; default based on key if none.\n * 3. Adjust index by direction, wrapping with modulo.\n * 4. Activate the new row and report handled.\n *\n * @param {\"ArrowUp\"|\"ArrowDown\"|\"ArrowLeft\"|\"ArrowRight\"} key - Pressed arrow key.\n * @returns {boolean} Whether the key was handled.\n */\nfunction handleStatListArrowKey(key) {\n  const list = byId(\"cli-stats\");\n  const rows = list ? Array.from(list.querySelectorAll(\".cli-stat\")) : [];\n  if (!list || rows.length === 0) return false;\n  const current = document.activeElement?.closest?.(\".cli-stat\");\n  let idx = rows.indexOf(current);\n  if (idx === -1) {\n    idx = key === \"ArrowUp\" || key === \"ArrowLeft\" ? rows.length - 1 : 0;\n  } else {\n    const delta = key === \"ArrowDown\" || key === \"ArrowRight\" ? 1 : -1;\n    idx = (idx + delta + rows.length) % rows.length;\n  }\n  setActiveStatRow(rows[idx]);\n  return true;\n}\n\n/**\n * Load stat names and render them into the CLI stat selection list.\n *\n * @summary Load stat names, build stat buttons, store display name map, and wire click handlers.\n * @pseudocode\n * 1. Initialize cached stat definitions from the stat names module if not already loaded.\n * 2. Locate `#cli-stats`; clear existing entries and display name map.\n * 3. Render each stat as a clickable element showing `[idx] name: value` when `judoka` provided.\n * 4. Populate `#cli-help` once with index-name mapping and clear any skeleton placeholders.\n *\n * @param {object} [judoka] - Optional judoka object providing current stat values.\n * @returns {Promise<void>} Resolves when the stat list has been rendered.\n */\nexport async function renderStatList(judoka) {\n  try {\n    if (!cachedStatDefs) {\n      // Prefer dynamic fetch in tests or when available so mocks can supply\n      // custom stat sets (e.g., Speed/Strength). Fallback to bundled module.\n      try {\n        const { fetchJson } = await import(\"../helpers/dataUtils.js\");\n        const { DATA_DIR } = await import(\"../helpers/constants.js\");\n        const defs = await fetchJson(`${DATA_DIR}/statNames.json`);\n        if (Array.isArray(defs) && defs.length) {\n          cachedStatDefs = defs;\n        }\n      } catch {}\n      if (!cachedStatDefs) cachedStatDefs = statNamesData;\n    }\n    const list = byId(\"cli-stats\");\n    const stats = Array.isArray(cachedStatDefs) ? cachedStatDefs : [];\n    if (list && stats.length) {\n      list.innerHTML = \"\";\n      for (const key of Object.keys(statDisplayNames)) delete statDisplayNames[key];\n      const rows = [];\n      stats\n        .slice()\n        .sort((a, b) => (a.statIndex || 0) - (b.statIndex || 0))\n        .forEach((s) => {\n          const idx = Number(s.statIndex) || 0;\n          if (!idx) return;\n          const key = STATS[idx - 1];\n          if (key) statDisplayNames[key] = s.name;\n          const div = document.createElement(\"div\");\n          div.className = \"cli-stat\";\n          div.id = `cli-stat-${idx}`;\n          div.setAttribute(\"role\", \"button\");\n          div.setAttribute(\"tabindex\", \"-1\");\n          div.dataset.statIndex = String(idx);\n          const val = Number(judoka?.stats?.[key]);\n          div.textContent = Number.isFinite(val)\n            ? `[${idx}] ${s.name}: ${val}`\n            : `[${idx}] ${s.name}`;\n          list.appendChild(div);\n          rows.push(div);\n        });\n      if (rows.length) setActiveStatRow(rows[0], { focus: false });\n      const onClick = handleStatListClick;\n      const boundTargets = (globalThis.__battleCLIStatListBoundTargets ||= new WeakSet());\n      if (!boundTargets.has(list)) {\n        list.addEventListener(\"click\", onClick);\n        boundTargets.add(list);\n      }\n      try {\n        window.__battleCLIinit?.clearSkeletonStats?.();\n      } catch {}\n      try {\n        const help = byId(\"cli-help\");\n        if (help && help.childElementCount === 0) {\n          const mapping = stats\n            .slice()\n            .sort((a, b) => (a.statIndex || 0) - (b.statIndex || 0))\n            .map((s) => `[${s.statIndex}] ${s.name}`)\n            .join(\"  ·  \");\n          const li = document.createElement(\"li\");\n          li.textContent = mapping;\n          help.appendChild(li);\n        }\n      } catch {}\n    }\n  } catch {}\n}\n\nfunction renderHiddenPlayerStats(judoka) {\n  try {\n    const card = byId(\"player-card\");\n    if (!card) return;\n    const ul = document.createElement(\"ul\");\n    STATS.forEach((stat) => {\n      const li = document.createElement(\"li\");\n      li.className = \"stat\";\n      const strong = document.createElement(\"strong\");\n      strong.textContent = statDisplayNames[stat] || stat;\n      const span = document.createElement(\"span\");\n      const val = Number(judoka?.stats?.[stat]);\n      span.textContent = Number.isFinite(val) ? String(val) : \"\";\n      li.appendChild(strong);\n      li.appendChild(document.createTextNode(\" \"));\n      li.appendChild(span);\n      ul.appendChild(li);\n    });\n    card.textContent = \"\";\n    card.appendChild(ul);\n  } catch {}\n}\n\n/**\n * Restore and persist the selected points-to-win value.\n *\n * @pseudocode\n * 1. Find `#points-select`; return if missing.\n * 2. Read saved value from storage and apply when valid.\n * 3. On select change:\n *    a. Ignore invalid values.\n *    b. Show confirm that scores reset and match restarts.\n *    c. If confirmed: save, apply, and reset without starting.\n *    d. Otherwise revert to previous value.\n */\n/**\n * Restore, persist, and handle changes to the points-to-win selector.\n *\n * @summary Read the saved points-to-win value, apply it, and prompt the user on change.\n * @pseudocode\n * 1. Locate `#points-select` and read stored value using the provided storage wrapper.\n * 2. If a stored value is valid, apply it and update the select control.\n * 3. On user change: validate the chosen value, confirm reset, persist and reset when confirmed.\n *\n * @returns {void}\n */\nexport function restorePointsToWin() {\n  try {\n    const select = byId(\"points-select\");\n    if (!select) return;\n    const storage = wrap(BATTLE_POINTS_TO_WIN, { fallback: \"none\" });\n    const saved = Number(storage.get());\n    if (POINTS_TO_WIN_OPTIONS.includes(saved)) {\n      engineFacade.setPointsToWin?.(saved);\n      select.value = String(saved);\n    }\n    const round = Number(byId(\"cli-root\")?.dataset.round || 0);\n    updateRoundHeader(round, engineFacade.getPointsToWin?.());\n    let current = Number(select.value);\n    select.addEventListener(\"change\", async () => {\n      const val = Number(select.value);\n      if (!POINTS_TO_WIN_OPTIONS.includes(val)) return;\n      if (window.confirm(\"Changing win target resets scores. Start a new match?\")) {\n        storage.set(val);\n        await resetMatch();\n        engineFacade.setPointsToWin?.(val);\n        updateRoundHeader(0, val);\n        renderStartButton();\n        current = val;\n      } else {\n        select.value = String(current);\n      }\n    });\n  } catch {}\n}\n\n/**\n * Start a new round and prepare the CLI UI.\n *\n * @pseudocode\n * 1. Call core `startRound` → { judoka, roundNumber }.\n * 2. Render the stat list with current values.\n * 3. Clear the round message and show the prompt.\n * 4. Update round header with roundNumber and points target.\n */\nasync function startRoundWrapper() {\n  const { playerJudoka, roundNumber } = await startRoundCore(store);\n  currentPlayerJudoka = playerJudoka || null;\n  await renderStatList(currentPlayerJudoka);\n  renderHiddenPlayerStats(currentPlayerJudoka);\n  setRoundMessage(\"\");\n  showBottomLine(\"Select your move\");\n  updateRoundHeader(roundNumber, engineFacade.getPointsToWin?.());\n}\n\nfunction getStatByIndex(index1Based) {\n  const i = Number(index1Based) - 1;\n  return STATS[i] || null;\n}\n\n/**\n * Handle global shortcuts that work in any state.\n * @param {string} key\n * @returns {boolean} true if the key was handled\n * @pseudocode\n * if key is 'h':\n *   toggle shortcuts panel\n *   return true\n * if key is 'q':\n *   show quit confirmation modal\n *   return true\n * return false\n */\nexport function handleGlobalKey(key) {\n  if (key === \"h\") {\n    const sec = byId(\"cli-shortcuts\");\n    if (sec) {\n      if (sec.hidden) {\n        shortcutsReturnFocus =\n          document.activeElement instanceof HTMLElement ? document.activeElement : null;\n        showCliShortcuts();\n        byId(\"cli-shortcuts-close\")?.focus();\n      } else {\n        hideCliShortcuts();\n      }\n    }\n    return true;\n  }\n  if (key === \"q\") {\n    showQuitModal();\n    return true;\n  }\n  return false;\n}\n\n/**\n * Handle key presses while waiting for the player to select a stat.\n * @param {string} key\n * @pseudocode\n * if key is between '1' and '9':\n *   lookup stat by index\n *   if stat missing: return false\n *   selectStat(stat)\n *   return true\n * return false\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * Handle key input while waiting for the player's stat selection.\n *\n * @summary Convert numeric key presses into stat selections when appropriate.\n * @param {string} key - Normalized single-character key value (e.g., '1').\n * @returns {boolean} True when the key was handled.\n * @pseudocode\n * if key is a digit:\n *   stat = getStatByIndex(key)\n *   if stat missing:\n *     showHint(\"Use 1-5, press H for help\")\n *     return true\n *   selectStat(stat)\n *   return true\n * return false\n */\nexport function handleWaitingForPlayerActionKey(key) {\n  if (key >= \"0\" && key <= \"9\") {\n    const stat = getStatByIndex(key);\n    if (!stat) {\n      showHint(\"Use 1-5, press H for help\");\n      return true;\n    }\n    selectStat(stat);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Handle key presses after a round has resolved.\n * @param {string} key\n * @pseudocode\n * if key is Enter or Space:\n *   dispatch 'continue'\n *   return true\n * return false\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * Handle key input after a round has resolved.\n *\n * @summary Treat Enter/Space as confirmation to continue to the next state.\n * @param {string} key - Normalized key value (lowercased or space string).\n * @returns {boolean} True when the key was handled.\n * @pseudocode\n * if key is Enter or Space:\n *   dispatch 'continue'\n *   return true\n * return false\n */\nexport function handleRoundOverKey(key) {\n  if (key === \"enter\" || key === \" \") {\n    try {\n      safeDispatch(\"continue\");\n    } catch {}\n    return true;\n  }\n  return false;\n}\n\n/**\n * Handle key presses during cooldown between rounds.\n * @param {string} key\n * @pseudocode\n * if key is Enter or Space:\n *   clear timers\n *   clear bottom line\n *   dispatch 'ready'\n *   return true\n * return false\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * @summary TODO: Add summary\n * @pseudocode\n * 1. TODO: Add pseudocode\n */\n/**\n * Handle key input during cooldown between rounds.\n *\n * @summary Allow Enter/Space to skip cooldown, clear timers, and mark machine as ready.\n * @param {string} key - Normalized key value.\n * @returns {boolean} True when the key was handled.\n * @pseudocode\n * if key is Enter or Space:\n *   clear timers\n *   clear bottom line\n *   dispatch 'ready'\n *   return true\n * return false\n */\nexport function handleCooldownKey(key) {\n  if (key === \"enter\" || key === \" \") {\n    try {\n      if (cooldownTimer) clearTimeout(cooldownTimer);\n    } catch {}\n    try {\n      if (cooldownInterval) clearInterval(cooldownInterval);\n    } catch {}\n    cooldownTimer = null;\n    cooldownInterval = null;\n    clearBottomLine();\n    try {\n      safeDispatch(\"ready\");\n    } catch {}\n    return true;\n  }\n  return false;\n}\n\n/**\n * Global keyboard handler that routes input based on the current battle state.\n *\n * @summary Normalize keyboard events, run global handlers, then state-specific handlers.\n * @param {KeyboardEvent} e - Browser keyboard event.\n * @returns {void}\n * @pseudocode\n * key = lowercased key from event\n * if cliShortcuts disabled AND key != 'q': return\n * state = document.body.dataset.battleState\n * table = { waitingForPlayerAction: handleWaitingForPlayerActionKey,\n *           roundOver: handleRoundOverKey,\n *           cooldown: handleCooldownKey }\n * if key == \"tab\": return\n * handler = table[state]\n * handled = handleGlobalKey(key) OR (handler ? handler(key) : false)\n * countdown = element '#cli-countdown'\n * if not handled:\n *   if countdown exists: set text to \"Invalid key, press H for help\"\n * else if countdown has text:\n *   clear countdown text\n */\nexport function onKeyDown(e) {\n  const key = e.key;\n  const list = byId(\"cli-stats\");\n  if (\n    list &&\n    [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"].includes(key) &&\n    (list === document.activeElement || list.contains(document.activeElement))\n  ) {\n    e.preventDefault();\n    handleStatListArrowKey(key);\n    return;\n  }\n  const lower = key.toLowerCase();\n  if (lower === \"escape\") return;\n  if (!isEnabled(\"cliShortcuts\") && lower !== \"q\") return;\n  const state = document.body?.dataset?.battleState || \"\";\n  const table = {\n    waitingForPlayerAction: handleWaitingForPlayerActionKey,\n    roundOver: handleRoundOverKey,\n    cooldown: handleCooldownKey\n  };\n  const handler = table[state];\n  const handled = handleGlobalKey(lower) || (handler ? handler(lower) : false);\n  const countdown = byId(\"cli-countdown\");\n  if (!handled && lower !== \"tab\") {\n    // Added key !== \"tab\"\n    if (countdown) countdown.textContent = \"Invalid key, press H for help\";\n  } else if (countdown && countdown.textContent) {\n    countdown.textContent = \"\";\n  }\n}\n\nfunction handleStatListClick(event) {\n  const list = byId(\"cli-stats\");\n  const statDiv = event.target?.closest?.(\".cli-stat\");\n  if (statDiv && list?.contains(statDiv)) {\n    setActiveStatRow(statDiv);\n    handleStatClick(statDiv, event);\n  }\n}\n\nfunction handleStatClick(statDiv, event) {\n  event.preventDefault();\n  const idx = statDiv?.dataset?.statIndex;\n  if (!idx) return;\n  const state = document.body?.dataset?.battleState || \"\";\n  if (state !== \"waitingForPlayerAction\") return;\n  const stat = getStatByIndex(idx);\n  if (!stat) return;\n  selectStat(stat);\n}\n\n/**\n * Advance battle state when clicking outside interactive areas.\n *\n * @pseudocode\n * if roundResolving or ignoreNextAdvanceClick -> return\n * state = body.dataset.battleState\n * if click inside .cli-stat or #cli-shortcuts -> return\n * if state == \"roundOver\" -> dispatch \"continue\"\n * else if state == \"cooldown\" -> clear timers, dispatch \"ready\"\n *\n * @param {MouseEvent} event - Click event.\n */\nfunction onClickAdvance(event) {\n  if (roundResolving) return;\n  if (ignoreNextAdvanceClick) {\n    // Consume exactly one background click after closing help.\n    ignoreNextAdvanceClick = false;\n    return;\n  }\n  // If help panel is open, ignore background clicks to avoid accidental advancement\n  const shortcutsPanel = byId(\"cli-shortcuts\");\n  if (shortcutsPanel && !shortcutsPanel.hidden) return;\n  let el = event.target;\n  let path = [];\n  while (el) {\n    path.push(el.tagName + (el.id ? \"#\" + el.id : \"\"));\n    el = el.parentElement;\n  }\n  const state = document.body?.dataset?.battleState || \"\";\n  if (event.target?.closest?.(\".cli-stat\")) return;\n  if (event.target?.closest?.(\"#cli-shortcuts\")) return;\n  if (state === \"roundOver\") {\n    try {\n      const machine = getMachine();\n      if (machine) machine.dispatch(\"continue\");\n    } catch {}\n  } else if (state === \"cooldown\") {\n    try {\n      if (cooldownTimer) clearTimeout(cooldownTimer);\n    } catch {}\n    try {\n      if (cooldownInterval) clearInterval(cooldownInterval);\n    } catch {}\n    cooldownTimer = null;\n    cooldownInterval = null;\n    clearBottomLine();\n    try {\n      const machine = getMachine();\n      if (machine) machine.dispatch(\"ready\");\n    } catch {}\n  }\n}\n\nfunction handleScoreboardShowMessage(e) {\n  setRoundMessage(String(e.detail || \"\"));\n}\n\nfunction handleScoreboardClearMessage() {\n  setRoundMessage(\"\");\n}\n\nfunction handleStatSelectionStalled() {\n  if (!isEnabled(\"autoSelect\")) {\n    showBottomLine(\"Stat selection stalled. Pick a stat.\");\n  }\n}\n\nfunction handleCountdownStart(e) {\n  if (skipRoundCooldownIfEnabled()) return;\n  const ds = typeof document !== \"undefined\" ? document.body?.dataset : undefined;\n  if (ds) ds.battleState = \"cooldown\";\n  const duration = Number(e.detail?.duration) || 0;\n  if (cooldownTimer) clearTimeout(cooldownTimer);\n  if (cooldownInterval) clearInterval(cooldownInterval);\n  cooldownTimer = null;\n  cooldownInterval = null;\n  if (duration > 0) {\n    let remaining = duration;\n    showBottomLine(`Next round in: ${remaining}`);\n    cooldownInterval = setInterval(() => {\n      remaining -= 1;\n      if (remaining > 0) showBottomLine(`Next round in: ${remaining}`);\n    }, 1000);\n    cooldownTimer = setTimeout(() => {\n      emitBattleEvent(\"countdownFinished\");\n    }, duration * 1000);\n  } else {\n    emitBattleEvent(\"countdownFinished\");\n  }\n}\n\nfunction handleCountdownFinished() {\n  if (cooldownTimer) clearTimeout(cooldownTimer);\n  if (cooldownInterval) clearInterval(cooldownInterval);\n  cooldownTimer = null;\n  cooldownInterval = null;\n  clearBottomLine();\n}\n\nfunction handleRoundResolved(e) {\n  roundResolving = false;\n  const { result, stat, playerVal, opponentVal } = e.detail || {};\n  if (result) {\n    const display = statDisplayNames[stat] || String(stat || \"\").toUpperCase();\n    setRoundMessage(`${result.message} (${display} – You: ${playerVal} Opponent: ${opponentVal})`);\n    updateScoreLine();\n  }\n}\n\n/**\n * Show restart controls when a match concludes.\n *\n * @pseudocode\n * 1. Locate `#cli-main`; abort if missing or already rendered.\n * 2. Build a \"Play again\" button that resets the match and restarts on click.\n * 3. If a home link exists, append a \"Return to lobby\" anchor using its href.\n * 4. Append the controls section to the main container.\n */\nfunction handleMatchOver() {\n  const main = byId(\"cli-main\");\n  if (!main || byId(\"play-again-button\")) return;\n  const section = document.createElement(\"section\");\n  section.className = \"cli-block\";\n  const btn = createButton(\"Play again\", {\n    id: \"play-again-button\",\n    className: \"primary-button\"\n  });\n  btn.addEventListener(\"click\", async () => {\n    await resetMatch();\n    section.remove();\n    emitBattleEvent(\"startClicked\");\n  });\n  section.append(btn);\n  try {\n    const homeHref = document.querySelector(\"[data-testid='home-link']\")?.getAttribute(\"href\");\n    if (homeHref) {\n      const link = document.createElement(\"a\");\n      link.id = \"return-to-lobby-link\";\n      link.href = homeHref;\n      link.textContent = \"Return to lobby\";\n      section.append(\" \", link);\n    }\n  } catch {}\n  main.append(section);\n}\n\nfunction handleBattleState(ev) {\n  const { from, to } = ev.detail || {};\n  updateBattleStateBadge(to);\n  // Clean up any transient Next button when state changes\n  try {\n    const existing = document.getElementById(\"next-round-button\");\n    if (existing) existing.remove();\n  } catch {}\n  if (to === \"matchStart\") {\n    clearVerboseLog();\n  }\n  if (to === \"waitingForPlayerAction\") {\n    startSelectionCountdown(30);\n    byId(\"cli-stats\")?.focus();\n  } else {\n    stopSelectionCountdown();\n  }\n  if (to === \"roundOver\" && !autoContinue) {\n    showBottomLine(\"Press Enter to continue\");\n    // Add an explicit, focusable Next button for pointer users\n    try {\n      const main = byId(\"cli-main\");\n      if (main && !document.getElementById(\"next-round-button\")) {\n        const section = document.createElement(\"section\");\n        section.className = \"cli-block\";\n        const btn = document.createElement(\"button\");\n        btn.id = \"next-round-button\";\n        btn.className = \"primary-button\";\n        btn.textContent = \"Next\";\n        btn.setAttribute(\"aria-label\", \"Continue to next round\");\n        btn.addEventListener(\"click\", () => {\n          try {\n            // clear timers and UI hints similar to cooldown skip\n            try {\n              if (cooldownTimer) clearTimeout(cooldownTimer);\n            } catch {}\n            try {\n              if (cooldownInterval) clearInterval(cooldownInterval);\n            } catch {}\n            cooldownTimer = null;\n            cooldownInterval = null;\n            clearBottomLine();\n          } catch {}\n          try {\n            safeDispatch(\"continue\");\n          } catch {}\n        });\n        section.appendChild(btn);\n        main.appendChild(section);\n        // Focus the button so keyboard users land on it after round resolution\n        try {\n          btn.focus();\n        } catch {}\n      }\n    } catch (err) {\n      console.error(\"Failed to render next-round-button\", err);\n    }\n  }\n  if (!verboseEnabled) return;\n  try {\n    const pre = byId(\"cli-verbose-log\");\n    if (!pre) return;\n    const ts = new Date();\n    const hh = String(ts.getHours()).padStart(2, \"0\");\n    const mm = String(ts.getMinutes()).padStart(2, \"0\");\n    const ss = String(ts.getSeconds()).padStart(2, \"0\");\n    const line = `[${hh}:${mm}:${ss}] ${from || \"(init)\"} -> ${to}`;\n    console.info(line);\n    const existing = pre.textContent ? pre.textContent.split(\"\\n\").filter(Boolean) : [];\n    existing.push(line);\n    while (existing.length > 50) existing.shift();\n    pre.textContent = existing.join(\"\\n\");\n    pre.scrollTop = pre.scrollHeight;\n  } catch {}\n}\n\nconst battleEventHandlers = {\n  scoreboardShowMessage: handleScoreboardShowMessage,\n  scoreboardClearMessage: handleScoreboardClearMessage,\n  statSelectionStalled: handleStatSelectionStalled,\n  countdownStart: handleCountdownStart,\n  countdownFinished: handleCountdownFinished,\n  roundResolved: handleRoundResolved,\n  matchOver: handleMatchOver\n};\n\nfunction installEventBindings() {\n  Object.entries(battleEventHandlers).forEach(([event, handler]) => onBattleEvent(event, handler));\n  onBattleEvent(\"battleStateChange\", handleBattleState);\n}\n\nasync function init() {\n  console.log(\"init called\");\n  initSeed();\n  store = createBattleStore();\n  // Expose store for debug panels if needed\n  try {\n    window.battleStore = store;\n  } catch {}\n  await renderStatList();\n  restorePointsToWin();\n  // Initialize feature flags and verbose section\n  const checkbox = byId(\"verbose-toggle\");\n  const section = byId(\"cli-verbose-section\");\n  const updateVerbose = () => {\n    // Use local source of truth for UI visibility to avoid relying on mocked isEnabled()\n    if (checkbox) checkbox.checked = !!verboseEnabled;\n    if (section) section.hidden = !verboseEnabled;\n    if (verboseEnabled) {\n      try {\n        const pre = byId(\"cli-verbose-log\");\n        if (pre) pre.scrollTop = pre.scrollHeight;\n      } catch {}\n    }\n  };\n\n  /**\n   * Toggle verbose flag while preserving win target.\n   *\n   * @pseudocode\n   * 1. Read current points-to-win.\n   * 2. Update verbose flag.\n   * 3. Reapply points-to-win and refresh header.\n   *\n   * @param {boolean} enable\n   * @returns {Promise<void>}\n   */\n  const toggleVerbose = async (enable) => {\n    const target = engineFacade.getPointsToWin?.();\n    // Update local state first so UI reflects change even when feature flags are mocked.\n    verboseEnabled = !!enable;\n    await setFlag(\"cliVerbose\", enable);\n    engineFacade.setPointsToWin?.(target);\n    const round = Number(byId(\"cli-root\")?.dataset.round || 0);\n    updateRoundHeader(round, target);\n    updateVerbose();\n  };\n  try {\n    await initFeatureFlags();\n  } catch {}\n  // Initialize local verbose state from flags once, then use local state thereafter.\n  try {\n    verboseEnabled = !!isEnabled(\"cliVerbose\");\n  } catch {}\n  setAutoContinue(true);\n  try {\n    const params = new URLSearchParams(location.search);\n    if (params.has(\"verbose\")) {\n      const v = params.get(\"verbose\");\n      await toggleVerbose(v === \"1\" || v === \"true\");\n    }\n    if (params.has(\"skipRoundCooldown\")) {\n      const skip = params.get(\"skipRoundCooldown\") === \"1\";\n      setFlag(\"skipRoundCooldown\", skip);\n    }\n    if (params.has(\"autoContinue\")) {\n      const v = params.get(\"autoContinue\");\n      setAutoContinue(!(v === \"0\" || v === \"false\"));\n    }\n  } catch {}\n  updateVerbose();\n  updateStateBadgeVisibility();\n  updateBattleStateBadge(getStateSnapshot().state);\n  updateCliShortcutsVisibility();\n  const close = byId(\"cli-shortcuts-close\");\n  close?.addEventListener(\"click\", (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n    // Set a guard to ignore the next background click after closing help.\n    // Do not clear it on microtask; it is consumed in onClickAdvance.\n    ignoreNextAdvanceClick = true;\n    hideCliShortcuts();\n  });\n  checkbox?.addEventListener(\"change\", async () => {\n    await toggleVerbose(!!checkbox.checked);\n  });\n  featureFlagsEmitter.addEventListener(\"change\", (e) => {\n    const flag = e.detail?.flag;\n    if (!flag || flag === \"cliVerbose\") {\n      try {\n        verboseEnabled = !!isEnabled(\"cliVerbose\");\n      } catch {}\n      const round = Number(byId(\"cli-root\")?.dataset.round || 0);\n      updateRoundHeader(round, engineFacade.getPointsToWin?.());\n      updateVerbose();\n    }\n    if (!flag || flag === \"battleStateBadge\") {\n      updateStateBadgeVisibility();\n    }\n    if (!flag || flag === \"cliShortcuts\") {\n      updateCliShortcutsVisibility();\n    }\n  });\n  // Install CLI event bridges\n  installEventBindings();\n  // Subscribe to engine events when provided by the facade.\n  try {\n    if (typeof engineFacade.on === \"function\") {\n      engineFacade.on(\"timerTick\", ({ remaining, phase }) => {\n        if (phase === \"round\") {\n          const el = byId(\"cli-timer\");\n          if (el) el.textContent = String(remaining);\n        }\n      });\n      engineFacade.on(\"matchEnded\", ({ outcome }) => {\n        setRoundMessage(`Match over: ${outcome}`);\n      });\n    }\n  } catch {}\n  // Initialize orchestrator using our startRound wrapper\n  // Kick off orchestrator init but don't await it; this keeps tests using fake timers from hanging.\n  try {\n    const p = battleOrchestrator.initClassicBattleOrchestrator?.(store, startRoundWrapper);\n    void p;\n  } catch {}\n  await renderStartButton();\n  // Keyboard controls\n  window.addEventListener(\"keydown\", onKeyDown);\n  document.addEventListener(\"click\", onClickAdvance);\n  // Pause/resume timers when the page visibility or lifecycle changes to avoid\n  // double-firing timers when the tab is hidden / device sleeps.\n  try {\n    document.addEventListener(\"visibilitychange\", () => {\n      if (document.hidden) pauseTimers();\n      else resumeTimers();\n    });\n    // pageshow/pagehide help with bfcache and mobile sleep/resume semantics\n    window.addEventListener(\"pageshow\", (ev) => {\n      // If the page was restored from the BFCache, ensure timers are resumed\n      try {\n        if (ev && ev.persisted) resumeTimers();\n      } catch {}\n    });\n    window.addEventListener(\"pagehide\", () => {\n      try {\n        pauseTimers();\n      } catch {}\n    });\n  } catch {}\n}\n\nif (!window.__TEST__) {\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", init);\n  } else {\n    init();\n  }\n}\n\n// Expose for tests\nif (typeof window !== \"undefined\") {\n  window.__test = __test;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/pages/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/utils/countryCodes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/utils/debounce.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/utils/deepMerge.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/utils/scheduler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/vendor/ajv6.min.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/src/vendor/marked.esm.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/cardBuilder.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/cardTopBar.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/epicCardBadge.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/judokaCardAccessibility.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/judokaCardFlip.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/judokaCardHtmlFallback.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/judokaCardInspectorInvalidData.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/judokaCardSignatureMove.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/judokaCardWeightClass.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/card/judokaZeroId.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/carousel/metrics.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/components/PlayerInfo.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/components/Scoreboard.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/components/SidebarList.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/components/StatsPanel.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/config/dataDir.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/config/loadSettings.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/data/aesopsMetaCrossCheck.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/data/schemaValidation.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/data/tooltipsEntries.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/fixtures/navigationItems.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/BattleEngine.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/CooldownRenderer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/TimerController.drift.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/addHoverZoomMarkers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/appendCards.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/autoSelectStat.min.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleEngine.pointsToWin.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleEngine/config.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleEngine/events.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleEngine/interrupts.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleEngine/multipleInstances.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleEngine/outcome.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleEngine/pauseResumeTimer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleEngineFacade.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleEngineTimer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleHeaderEllipsis.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleJudokaPage.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/battleTestUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/bottomNavigation.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/browseJudokaPage.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/buildMenu.ssr.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/buttonComponent.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/buttonEffects.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/cardBuilder.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/cardCode.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/cardComponent.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/cardUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/carouselBuilder.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/carouselController.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/changeLogPage.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/battleStateBadge.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/battleStateProgress.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/cardSelection.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/commonMocks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/controlState.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/controller.startRound.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/cooldown.skipHandlerReady.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/cooldownEnter.autoAdvance.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/cooldownEnter.zeroDuration.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/countdownReset.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/debugCopy.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/debugPanel.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/difficulty.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/domUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/drawNextRound.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/driftStarter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/initClassicBattle.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/interruptFlow.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/interruptHandlers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/interruptRoundEnter.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/matchEnd.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/mockSetup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/mocks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/nextButton.cooldown.fallback.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/nextButton.countdownFinished.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/nextButton.manualClick.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'expect' is defined but never used.","line":1,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"expect"},"fix":{"range":[21,29],"text":""},"desc":"Remove unused variable 'expect'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, afterEach } from \"vitest\";\nimport { __setStateSnapshot } from \"../../../src/helpers/classicBattle/battleDebug.js\";\n\nvi.mock(\"../../../src/helpers/classicBattle/skipHandler.js\", () => ({\n  setSkipHandler: vi.fn()\n}));\n\ndescribe(\"Next button manual click\", () => {\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  it(\"dispatches ready within 50ms\", async () => {\n    document.body.innerHTML = '<button id=\"next-button\" data-role=\"next-round\"></button>';\n    const dispatcher = await import(\"../../../src/helpers/classicBattle/orchestrator.js\");\n    const mod = await import(\"../../../src/helpers/classicBattle/timerService.js\");\n    __setStateSnapshot({ state: \"cooldown\" });\n\n    const readyPromise = new Promise((resolve, reject) => {\n      const timer = setTimeout(() => reject(new Error(\"ready not dispatched\")), 50);\n      vi.spyOn(dispatcher, \"dispatchBattleEvent\").mockImplementation(async (evt) => {\n        if (evt === \"ready\") {\n          clearTimeout(timer);\n          resolve();\n        }\n      });\n    });\n\n    await mod.onNextButtonClick(new MouseEvent(\"click\"), { timer: null, resolveReady: null });\n    await readyPromise;\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/onTransition.helpers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/opponentDelay.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/orchestrator.events.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/pauseTimer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/playRounds.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/playerChoiceReset.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/quitModal.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/race.statSelected.startup.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/rebindEngineEvents.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/roundDecisionGuard.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/roundReset.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/roundResolved.statButton.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/roundResolverOnce.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/roundSelectModal.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/roundStartError.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/scheduleNextRound.fallback.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/scheduleNextRound.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/selectionHandler.resolve.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/setupTestEnv.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/stallRecovery.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/statDoubleClick.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/statSelection.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/statSelectionTiming.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/stateTransitions.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/timeoutInterrupt.cooldown.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/timerService.drift.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/timerService.nextRound.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/timerStateExposure.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/uiHelpers.missingElements.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/view.initHelpers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattle/waitingForPlayerAction.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattleBindings.idempotent.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattleFlags.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattlePage.startRoundWrapper.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/classicBattlePage.syncScoreDisplay.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/colorContrast.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/coreUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/countrySlider.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/createCountdownTimer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/createInspectorPanel.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/cssVariableParser.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/dataUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/debugClassToggles.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/displayMode.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/domReady.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/errorUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/featureFlags.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/focusHandlers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/gameModeUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/gameRandom.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/handleKeyboardNavigation.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/headerLogoLinkCss.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/helpers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/initClassicBattleTest.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/judokaCard.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/judokaValidation.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/keyboardNavigation.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/layoutDebugPanel.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/markdownToHtml.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/meditationContrast.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/mockEnv.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/mockScheduler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/mockupViewerPage.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/modalComponent.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/modalManager.callbacks.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/modalManager.stack.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/motionUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/mountInspectorPanel.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/navMenuResponsive.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/navigationCache.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/navigationTooltips.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/orchestrator.stateChange.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/orchestratorHandlers.computeOutcome.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/orchestratorHandlers.helpers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/orchestratorHandlers.roundDecisionEnter.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/orientation.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/parseTooltipText.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/populateCountryList.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/prdReaderPage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/prdReaderPage.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/prdTaskStats.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/pseudoJapanese.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/quoteBuilder.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/randomCard.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/randomJudokaPage.drawButton.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/randomJudokaPage.featureFlags.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/randomJudokaPage.historyPanel.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/roundResolver.resolveRound.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/roundSelectModal.storage.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/scoreboard.integration.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/scrollButtonState.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/scrollMarkers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/selectionHandler.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/settingsCache.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/settingsFormUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/settingsPage.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'defaultSettings' is defined but never used.","line":3,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":23,"suggestions":[{"messageId":"removeVar","data":{"varName":"defaultSettings"},"fix":{"range":[139,160],"text":""},"desc":"Remove unused variable 'defaultSettings'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport { createSettingsDom, resetDom } from \"../utils/testUtils.js\";\nimport defaultSettings from \"../../src/data/settings.json\" with { type: \"json\" };\n\nconst baseSettings = {\n  sound: true,\n  motionEffects: true,\n  typewriterEffect: true,\n  tooltips: true,\n  showCardOfTheDay: false,\n  displayMode: \"light\",\n  fullNavigationMap: true,\n  gameModes: {},\n  featureFlags: {\n    enableTestMode: { enabled: false },\n    enableCardInspector: { enabled: false },\n    viewportSimulation: { enabled: false },\n    tooltipOverlayDebug: { enabled: false },\n    layoutDebugPanel: { enabled: false, tooltipId: \"settings.layoutDebugPanel\" },\n    navCacheResetButton: { enabled: false }\n  }\n};\n\nconst tooltipMap = {\n  \"settings.fullNavigationMap.label\": \"Full Navigation Map\",\n  \"settings.fullNavigationMap.description\": \"Expanded map navigation\",\n  \"settings.enableTestMode.label\": \"Test Mode\",\n  \"settings.enableTestMode.description\": \"Deterministic card draws for testing\",\n  \"settings.enableCardInspector.label\": \"Card Inspector\",\n  \"settings.enableCardInspector.description\": \"Shows raw card JSON in a panel\",\n  \"settings.showCardOfTheDay.label\": \"Card Of The Day\",\n  \"settings.showCardOfTheDay.description\":\n    \"Displays a rotating featured judoka card on the landing screen\",\n  \"settings.viewportSimulation.label\": \"Viewport Simulation\",\n  \"settings.viewportSimulation.description\":\n    \"Adds a dropdown to simulate common device viewport sizes\",\n  \"settings.tooltipOverlayDebug.label\": \"Tooltip Overlay Debug\",\n  \"settings.tooltipOverlayDebug.description\": \"Shows bounding boxes for tooltip targets\",\n  \"settings.layoutDebugPanel.label\": \"Layout Debug Panel\",\n  \"settings.layoutDebugPanel.description\":\n    \"Displays CSS grid and flex outlines for debugging layout issues\",\n  \"settings.navCacheResetButton.label\": \"Navigation Cache Reset\",\n  \"settings.navCacheResetButton.description\":\n    \"Adds a button to clear cached navigation data for troubleshooting\"\n};\n\nlet currentFlags = baseSettings.featureFlags;\n\nbeforeEach(() => {\n  resetDom();\n  document.body.appendChild(createSettingsDom());\n  vi.doMock(\"../../src/helpers/tooltip.js\", () => ({\n    initTooltips: vi.fn().mockResolvedValue(() => {}),\n    getTooltips: vi.fn()\n  }));\n  vi.doMock(\"../../src/helpers/displayMode.js\", () => ({ applyDisplayMode: vi.fn() }));\n  vi.doMock(\"../../src/helpers/motionUtils.js\", () => ({ applyMotionPreference: vi.fn() }));\n  vi.doMock(\"../../src/helpers/viewportDebug.js\", () => ({ toggleViewportSimulation: vi.fn() }));\n  vi.doMock(\"../../src/helpers/tooltipOverlayDebug.js\", () => ({\n    toggleTooltipOverlayDebug: vi.fn()\n  }));\n  vi.doMock(\"../../src/helpers/layoutDebugPanel.js\", () => ({ toggleLayoutDebugPanel: vi.fn() }));\n  vi.doMock(\"../../src/helpers/domReady.js\", () => ({ onDomReady: vi.fn() }));\n  vi.doMock(\"../../src/helpers/featureFlags.js\", () => ({\n    isEnabled: (flag) => currentFlags[flag]?.enabled ?? false,\n    initFeatureFlags: vi.fn().mockResolvedValue(baseSettings)\n  }));\n  vi.doMock(\"../../src/helpers/gameModeUtils.js\", () => ({\n    loadNavigationItems: vi.fn().mockResolvedValue([])\n  }));\n});\n\ndescribe(\"fetchSettingsData\", () => {\n  it(\"rejects on fetch failure\", async () => {\n    vi.resetModules();\n    vi.doMock(\"../../src/helpers/gameModeUtils.js\", () => ({\n      loadNavigationItems: vi.fn().mockResolvedValue([])\n    }));\n    vi.doMock(\"../../src/helpers/tooltip.js\", () => ({\n      getTooltips: vi.fn().mockResolvedValue({}),\n      initTooltips: vi.fn().mockResolvedValue(() => {})\n    }));\n    vi.doMock(\"../../src/helpers/featureFlags.js\", () => ({\n      initFeatureFlags: vi.fn().mockRejectedValue(new Error(\"fail\")),\n      isEnabled: vi.fn()\n    }));\n    const { fetchSettingsData } = await import(\"../../src/helpers/settingsPage.js\");\n    await expect(fetchSettingsData()).rejects.toThrow(\"Failed to fetch settings data\");\n  });\n});\n\ndescribe(\"renderSettingsControls\", () => {\n  it(\"renders expected toggles\", async () => {\n    const gameModes = [\n      { id: 1, name: \"Classic\", category: \"mainMenu\", order: 10 },\n      { id: 2, name: \"Blitz\", category: \"bonus\", order: 20 },\n      { id: 3, name: \"Dojo\", category: \"mainMenu\", order: 30 }\n    ];\n    const { renderSettingsControls } = await import(\"../../src/helpers/settingsPage.js\");\n    renderSettingsControls(baseSettings, gameModes, tooltipMap);\n    const container = document.getElementById(\"game-mode-toggle-container\");\n    const checkboxes = container.querySelectorAll(\"input[type='checkbox']\");\n    expect(checkboxes).toHaveLength(3);\n    expect(document.getElementById(\"feature-enable-test-mode\")).toBeTruthy();\n  });\n\n  it(\"updates navigation hidden state when a mode is toggled\", async () => {\n    const gameModes = [{ id: 1, name: \"Classic\", category: \"mainMenu\", isHidden: false }];\n    const updateSetting = vi.fn().mockResolvedValue(baseSettings);\n    const updateNavigationItemHidden = vi.fn().mockResolvedValue([]);\n    vi.doMock(\"../../src/helpers/settingsStorage.js\", () => ({\n      updateSetting,\n      loadSettings: vi.fn(),\n      resetSettings: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/gameModeUtils.js\", () => ({\n      updateNavigationItemHidden,\n      loadNavigationItems: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/showSnackbar.js\", () => ({\n      showSnackbar: vi.fn(),\n      updateSnackbar: vi.fn()\n    }));\n    const { renderSettingsControls, handleGameModeChange } = await import(\n      \"../../src/helpers/settingsPage.js\"\n    );\n    renderSettingsControls(baseSettings, gameModes, tooltipMap);\n    const input = document.getElementById(\"mode-1\");\n    input.checked = false;\n    await handleGameModeChange({\n      input,\n      mode: gameModes[0],\n      label: gameModes[0].name,\n      getCurrentSettings: () => baseSettings,\n      handleUpdate: updateSetting\n    });\n    expect(updateNavigationItemHidden).toHaveBeenCalledWith(1, true);\n  });\n\n  it(\"persists feature flag changes\", async () => {\n    const updateSetting = vi.fn().mockResolvedValue(baseSettings);\n    vi.doMock(\"../../src/helpers/settingsStorage.js\", () => ({\n      updateSetting,\n      loadSettings: vi.fn(),\n      resetSettings: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/showSnackbar.js\", () => ({\n      showSnackbar: vi.fn(),\n      updateSnackbar: vi.fn()\n    }));\n    const { renderSettingsControls, handleFeatureFlagChange } = await import(\n      \"../../src/helpers/settingsPage.js\"\n    );\n    renderSettingsControls(baseSettings, [], tooltipMap);\n    const input = document.querySelector(\"#feature-enable-test-mode\");\n    input.checked = true;\n    await handleFeatureFlagChange({\n      input,\n      flag: \"enableTestMode\",\n      info: baseSettings.featureFlags.enableTestMode,\n      label: \"enableTestMode\",\n      getCurrentSettings: () => baseSettings,\n      handleUpdate: updateSetting\n    });\n    expect(updateSetting).toHaveBeenCalledWith(\n      \"featureFlags\",\n      {\n        ...baseSettings.featureFlags,\n        enableTestMode: { enabled: true }\n      },\n      expect.any(Function)\n    );\n  });\n\n  it(\"adds navigation cache reset button when flag enabled\", async () => {\n    const settingsWithButton = {\n      ...baseSettings,\n      featureFlags: {\n        ...baseSettings.featureFlags,\n        navCacheResetButton: { ...baseSettings.featureFlags.navCacheResetButton, enabled: true }\n      }\n    };\n    const populateNavbar = vi.fn();\n    const showSnackbar = vi.fn();\n    const resetNavigationCache = vi.fn();\n    vi.doMock(\"../../src/helpers/navigationBar.js\", () => ({ populateNavbar }));\n    vi.doMock(\"../../src/helpers/showSnackbar.js\", () => ({\n      showSnackbar,\n      updateSnackbar: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/navigationCache.js\", () => ({ reset: resetNavigationCache }));\n    currentFlags = settingsWithButton.featureFlags;\n    const { renderSettingsControls } = await import(\"../../src/helpers/settingsPage.js\");\n    renderSettingsControls(settingsWithButton, [], tooltipMap);\n    await Promise.resolve();\n    await Promise.resolve();\n    const btn = document.getElementById(\"nav-cache-reset-button\");\n    expect(btn).toBeTruthy();\n    btn.dispatchEvent(new Event(\"click\"));\n    expect(resetNavigationCache).toHaveBeenCalled();\n    expect(populateNavbar).toHaveBeenCalled();\n    expect(showSnackbar).toHaveBeenCalledWith(\"Navigation cache cleared\");\n  });\n\n  it(\"restores defaults when confirmed\", async () => {\n    const resetSettings = vi.fn();\n    const initFeatureFlags = vi.fn().mockImplementation(async () => {\n      currentFlags = baseSettings.featureFlags;\n      return baseSettings;\n    });\n    const showSnackbar = vi.fn();\n    vi.doMock(\"../../src/helpers/settingsStorage.js\", () => ({\n      updateSetting: vi.fn(),\n      loadSettings: vi.fn(),\n      resetSettings\n    }));\n    vi.doMock(\"../../src/helpers/featureFlags.js\", () => ({\n      isEnabled: (flag) => currentFlags[flag]?.enabled ?? false,\n      initFeatureFlags\n    }));\n    vi.doMock(\"../../src/helpers/showSnackbar.js\", () => ({\n      showSnackbar,\n      updateSnackbar: vi.fn()\n    }));\n    const { renderSettingsControls } = await import(\"../../src/helpers/settingsPage.js\");\n    const settingsWithFlag = {\n      ...baseSettings,\n      featureFlags: {\n        ...baseSettings.featureFlags,\n        enableTestMode: { enabled: true }\n      }\n    };\n    currentFlags = settingsWithFlag.featureFlags;\n    renderSettingsControls(settingsWithFlag, [], tooltipMap);\n    expect(document.getElementById(\"feature-enable-test-mode\").checked).toBe(true);\n    document.getElementById(\"reset-settings-button\").dispatchEvent(new Event(\"click\"));\n    document.getElementById(\"confirm-reset-button\").dispatchEvent(new Event(\"click\"));\n    await Promise.resolve();\n    expect(resetSettings).toHaveBeenCalled();\n    expect(initFeatureFlags).toHaveBeenCalled();\n    expect(showSnackbar).toHaveBeenCalledWith(\"Settings restored to defaults\");\n    expect(document.getElementById(\"feature-enable-test-mode\").checked).toBe(false);\n  });\n\n  it(\"does not duplicate reset listener on reinit\", async () => {\n    const { renderSettingsControls } = await import(\"../../src/helpers/settingsPage.js\");\n    renderSettingsControls(baseSettings, [], tooltipMap);\n    const resetButton = document.getElementById(\"reset-settings-button\");\n    const addSpy = vi.spyOn(resetButton, \"addEventListener\");\n    renderSettingsControls(baseSettings, [], tooltipMap);\n    expect(addSpy).not.toHaveBeenCalled();\n    addSpy.mockRestore();\n  });\n\n  it(\"renders missing feature flags from defaults\", async () => {\n    const { renderSettingsControls } = await import(\"../../src/helpers/settingsPage.js\");\n    const withoutFlag = {\n      ...baseSettings,\n      featureFlags: { ...baseSettings.featureFlags }\n    };\n    delete withoutFlag.featureFlags.navCacheResetButton;\n    currentFlags = withoutFlag.featureFlags;\n    renderSettingsControls(withoutFlag, [], tooltipMap);\n    expect(document.getElementById(\"feature-nav-cache-reset-button\")).toBeTruthy();\n  });\n});\n\ndescribe(\"initializeSettingsPage\", () => {\n  it(\"shows error and skips toggles when navigation items fail\", async () => {\n    vi.resetModules();\n    const consoleError = vi.spyOn(console, \"error\").mockImplementation(() => {});\n    const showSettingsError = vi.fn();\n    vi.doMock(\"../../src/helpers/showSettingsError.js\", () => ({\n      showSettingsError\n    }));\n    vi.doMock(\"../../src/helpers/featureFlags.js\", () => ({\n      initFeatureFlags: vi.fn().mockResolvedValue(baseSettings),\n      isEnabled: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/gameModeUtils.js\", () => ({\n      loadNavigationItems: vi.fn().mockRejectedValueOnce(new Error(\"nav fail\"))\n    }));\n    const onDomReady = vi.fn();\n    vi.doMock(\"../../src/helpers/domReady.js\", () => ({ onDomReady }));\n    document.body.appendChild(\n      Object.assign(document.createElement(\"div\"), { id: \"settings-error-popup\" })\n    );\n    await import(\"../../src/helpers/settingsPage.js\");\n    const init = onDomReady.mock.calls[0][0];\n    await init();\n    const popup = document.getElementById(\"settings-error-popup\");\n    expect(popup.style.display).toBe(\"block\");\n    expect(showSettingsError).toHaveBeenCalled();\n    expect(document.querySelectorAll(\"#game-mode-toggle-container input\")).toHaveLength(0);\n    consoleError.mockRestore();\n  });\n\n  it(\"renders game mode toggles when cache load fails\", async () => {\n    vi.resetModules();\n    const consoleError = vi.spyOn(console, \"error\").mockImplementation(() => {});\n    const navItems = [\n      {\n        id: 1,\n        url: \"classic.html\",\n        category: \"mainMenu\",\n        order: 10,\n        isHidden: false,\n        gameModeId: 1\n      }\n    ];\n    const modes = [{ id: 1, name: \"Classic\", category: \"mainMenu\" }];\n    vi.doMock(\"../../src/helpers/navigationCache.js\", () => ({\n      load: vi.fn().mockRejectedValue(new Error(\"cache error\")),\n      save: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/gameModeUtils.js\", () => ({\n      loadNavigationItems: vi\n        .fn()\n        .mockResolvedValue(navItems.map((item) => ({ ...item, ...modes[0] }))),\n      updateNavigationItemHidden: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/featureFlags.js\", () => ({\n      initFeatureFlags: vi.fn().mockResolvedValue(baseSettings),\n      isEnabled: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/tooltip.js\", () => ({\n      initTooltips: vi.fn().mockResolvedValue(() => {}),\n      getTooltips: vi.fn().mockResolvedValue({})\n    }));\n    vi.doMock(\"../../src/helpers/displayMode.js\", () => ({\n      applyDisplayMode: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/motionUtils.js\", () => ({\n      applyMotionPreference: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/viewportDebug.js\", () => ({\n      toggleViewportSimulation: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/tooltipOverlayDebug.js\", () => ({\n      toggleTooltipOverlayDebug: vi.fn()\n    }));\n    vi.doMock(\"../../src/helpers/layoutDebugPanel.js\", () => ({\n      toggleLayoutDebugPanel: vi.fn()\n    }));\n    global.fetch = vi.fn().mockResolvedValue({ ok: true, json: async () => ({}) });\n    const onDomReady = vi.fn();\n    vi.doMock(\"../../src/helpers/domReady.js\", () => ({ onDomReady }));\n    await import(\"../../src/helpers/settingsPage.js\");\n    const init = onDomReady.mock.calls[0][0];\n    await init();\n    const checkboxes = document.querySelectorAll(\"#game-mode-toggle-container input\");\n    expect(checkboxes).toHaveLength(1);\n    expect(document.getElementById(\"mode-1\")).toBeTruthy();\n    consoleError.mockRestore();\n  });\n});\n\ndescribe(\"renderWithFallbacks\", () => {\n  it(\"shows error when game modes are missing\", async () => {\n    const { renderWithFallbacks } = await import(\"../../src/helpers/settingsPage.js\");\n    renderWithFallbacks({ settings: baseSettings, gameModes: [], tooltipMap: {} });\n    const errorEl = document.querySelector(\"#game-mode-toggle-container .settings-section-error\");\n    expect(errorEl?.textContent).toBe(\n      \"Game Modes could not be loaded. Please check your connection or try again later.\"\n    );\n  });\n\n  it(\"shows error when feature flags are missing\", async () => {\n    const badSettings = { ...baseSettings };\n    // remove featureFlags to trigger error\n    delete badSettings.featureFlags;\n    const { renderWithFallbacks } = await import(\"../../src/helpers/settingsPage.js\");\n    renderWithFallbacks({\n      settings: badSettings,\n      gameModes: [{ id: 1, name: \"Classic\", category: \"mainMenu\" }],\n      tooltipMap: {}\n    });\n    const errorEl = document.querySelector(\"#feature-flags-container .settings-section-error\");\n    expect(errorEl?.textContent).toBe(\n      \"Advanced Settings could not be loaded. Please check your connection or try again later.\"\n    );\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/settingsRenderers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/settingsStorage.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/settingsUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/setupBottomNavbar.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/setupCarouselToggle.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/setupScoreboard.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/showSettingsError.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/showSnackbar.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/snackbarContainerOrder.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/stats.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/svgFallback.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/swipeNavigation.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/testModeUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/timerService.autoSelect.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/timerService.autoSelectDisabled.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/timerService.cooldownGuard.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/timerService.onNextButtonClick.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/timerService.ordering.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/timerService.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/timerUtils.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/timers/createRoundTimer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/toggleSwitch.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/tooltip.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/tooltipViewerPage.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/typewriter.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/uiHelpers.collectDebugState.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/uiHelpers.resetBattleUI.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/updateCodes.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearch.context.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearch.loader.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearch.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearch/mockDataset.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearchIndex.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearchPage/errorHandling.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearchPage/fixtures.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearchPage/queryBuilding.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearchPage/rendering.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearchPage/tagFilter.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/vectorSearchQuery.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/viewTransitionTheme.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/helpers/visibilityTimer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.a11y.controlsHint.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.a11y.focus.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.cliShortcutsFlag.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.countdown.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.handlers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.init.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.invalidNumber.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.onKeyDown.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.pointsToWin.startOnce.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.pointsToWin.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.retroTheme.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.roundHeader.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.scoreboard.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.seed.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.seedValidation.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.selectedStat.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.verbose.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.verboseFlag.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.verboseToggle.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'vi' is defined but never used.","line":1,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":45,"suggestions":[{"messageId":"removeVar","data":{"varName":"vi"},"fix":{"range":[40,44],"text":""},"desc":"Remove unused variable 'vi'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, afterEach, vi } from \"vitest\";\nimport { loadBattleCLI, cleanupBattleCLI } from \"./utils/loadBattleCLI.js\";\n\ndescribe(\"battleCLI verbose toggle\", () => {\n  afterEach(async () => {\n    await cleanupBattleCLI();\n  });\n\n  it(\"shows verbose section and logs after enabling mid-match\", async () => {\n    const mod = await loadBattleCLI();\n    await mod.__test.init();\n    const { emitBattleEvent } = await import(\"../../src/helpers/classicBattle/battleEvents.js\");\n    const section = document.getElementById(\"cli-verbose-section\");\n    const pre = document.getElementById(\"cli-verbose-log\");\n    emitBattleEvent(\"battleStateChange\", { from: \"a\", to: \"b\" });\n    expect(section.hidden).toBe(true);\n    expect(pre.textContent).toBe(\"\");\n    const checkbox = document.getElementById(\"verbose-toggle\");\n    checkbox.checked = true;\n    checkbox.dispatchEvent(new Event(\"change\"));\n    await Promise.resolve();\n    emitBattleEvent(\"battleStateChange\", { from: \"c\", to: \"d\" });\n    expect(section.hidden).toBe(false);\n    expect(pre.textContent).toMatch(/c -> d/);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleCLI.verboseWinTarget.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleClassic.a11y.smoke.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battleClassic.roundStart.dom.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/battlePages.dom.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/pages/utils/loadBattleCLI.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/queryRag/queryRag.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/scripts/check-jsdoc.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/scripts/collectTestStats.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/scripts/evaluateRAG.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/scripts/generateEmbeddings.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/setup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/styles/battleCLI.focusContrast.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/styles/battleContrast.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/styles/bottomNavbarCss.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/utils/console.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/utils/countryCodes.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/utils/debounce.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/utils/deepMerge.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/utils/testUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/vectorSearch/vectorSearchHelpers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/waitFor.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/tests/waitForState.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/updateCodes.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/vitest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/judokon/judokon/vitest.style.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
